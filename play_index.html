<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Ama Treasure Adventure - Complete Edition</title>
    <style>
      body {
        margin: 0;
        font-family: Arial, sans-serif;
        overflow: hidden;
        background: linear-gradient(to bottom right, #87ceeb, #f08080);
      }

      #game-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #1a1a1a;
        padding: 20px;
      }

      .game-stats {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1000;
        color: white;
        font-size: 18px;
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
      }

      .game-header-buttons {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        z-index: 1000;
      }

      .game-header-button {
        padding: 10px 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.2s;
        border: none;
        font-weight: bold;
      }

      .game-header-button:hover {
        background: rgba(0, 0, 0, 0.9);
        transform: translateY(-2px);
      }

      .exit-button {
        background: rgba(220, 53, 69, 0.8);
      }

      .exit-button:hover {
        background: rgba(220, 53, 69, 0.9);
      }

      .pause-button {
        background: rgba(255, 193, 7, 0.8);
        color: black;
      }

      .pause-button:hover {
        background: rgba(255, 193, 7, 0.9);
      }

      #startscreen {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        width: 90%;
        max-width: 600px;
        z-index: 1000;
        max-height: 90vh;
        overflow-y: auto;
      }

      #game {
        position: relative;
        width: 80vw;
        height: 80vh;
        border: 10px solid rgba(0, 0, 0, 0.8);
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        background-image: url("data/mermaid-background-1.png");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
      }

      .sprite {
        position: absolute;
        font-size: 50px;
        transition: all 0.1s ease-out;
        z-index: 2;
        user-select: none;
      }

      .obstacle {
        font-size: 60px;
        z-index: 1;
        animation: bounce 2s infinite ease-in-out;
      }

      .power-up {
        font-size: 40px;
        z-index: 2;
        animation: float 2s infinite ease-in-out;
        cursor: pointer;
      }

      .magnet-active {
        animation: pulse 1s infinite ease-in-out;
      }

      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-5px);
        }
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0px) scale(1);
        }
        50% {
          transform: translateY(-10px) scale(1.1);
        }
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(255, 165, 0, 0.7);
        }
        70% {
          transform: scale(1.1);
          box-shadow: 0 0 0 10px rgba(255, 165, 0, 0);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(255, 165, 0, 0);
        }
      }

      #gameover,
      #achievement {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        text-align: center;
        border-radius: 15px;
        z-index: 1000;
        display: none;
        max-width: 400px;
      }

      #achievement {
        top: 20%;
        background: rgba(0, 150, 0, 0.9);
        font-size: 18px;
        animation: slideIn 0.5s ease-out;
      }

      @keyframes slideIn {
        from {
          transform: translate(-50%, -100%);
          opacity: 0;
        }
        to {
          transform: translate(-50%, -50%);
          opacity: 1;
        }
      }

      button {
        font-size: 18px;
        padding: 12px 24px;
        margin: 10px;
        border: none;
        border-radius: 8px;
        background: linear-gradient(45deg, #ff6b35, #f7931e);
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: bold;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
      }

      .game-title {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 32px;
        font-weight: bold;
        background: linear-gradient(
          to right,
          #462523 0%,
          #cb9b51 22%,
          #f6e27a 45%,
          #f6f2c0 50%,
          #f6e27a 55%,
          #cb9b51 78%,
          #462523 100%
        );
        background-size: 600px;
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
        -webkit-text-fill-color: transparent;
        animation: shine 3s infinite linear;
        z-index: 1000;
      }

      @keyframes shine {
        0% {
          background-position: 0;
        }
        60% {
          background-position: 600px;
        }
        100% {
          background-position: 600px;
        }
      }

      input {
        font-size: 16px;
        padding: 12px;
        margin: 10px;
        border-radius: 8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.1);
        color: white;
        width: 80%;
        max-width: 300px;
      }

      input:focus {
        outline: none;
        border-color: orange;
        background: rgba(255, 255, 255, 0.2);
      }

      input::placeholder {
        color: rgba(255, 255, 255, 0.6);
      }

      .mode-selection {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .mode-button {
        padding: 20px 30px;
        font-size: 18px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 220px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      .mode-button:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-3px);
      }

      .mode-button.selected {
        background: rgba(255, 165, 0, 0.4);
        border-color: orange;
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(255, 165, 0, 0.4);
      }

      .mode-button .icon {
        font-size: 36px;
      }

      .mode-button .description {
        font-size: 14px;
        opacity: 0.8;
      }

      .power-up-status {
        position: fixed;
        top: 100px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 8px;
        z-index: 1000;
        display: none;
      }

      .audio-toggle-button {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1001;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }

      .audio-toggle-button:hover {
        background: rgba(0, 0, 0, 0.9);
        transform: scale(1.1);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }

      .audio-toggle-button.active {
        background: rgba(255, 165, 0, 0.8);
        animation: pulse-audio 2s infinite;
      }

      @keyframes pulse-audio {
        0% {
          box-shadow: 0 4px 15px rgba(255, 165, 0, 0.3);
        }
        50% {
          box-shadow: 0 4px 25px rgba(255, 165, 0, 0.6);
        }
        100% {
          box-shadow: 0 4px 15px rgba(255, 165, 0, 0.3);
        }
      }

      .audio-controls {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(0, 0, 0, 0.9);
        padding: 20px;
        border-radius: 12px;
        color: white;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 15px;
        min-width: 220px;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transform: translateY(-10px);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .audio-controls.expanded {
        max-height: 300px;
        opacity: 1;
        transform: translateY(0);
      }

      .audio-controls h3 {
        margin: 0 0 10px 0;
        text-align: center;
        font-size: 18px;
        color: orange;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        padding-bottom: 10px;
      }

      .audio-controls button {
        padding: 8px;
        font-size: 14px;
        margin: 0;
      }

      .volume-control {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .volume-control input[type="range"] {
        flex: 1;
        width: auto;
        margin: 0;
        padding: 0;
      }

      #how-to-play {
        text-align: left;
        font-size: 16px;
        line-height: 1.6em;
        margin: 20px 0;
      }

      #how-to-play summary {
        cursor: pointer;
        font-size: 20px;
        margin-bottom: 15px;
        text-align: center;
        color: orange;
        font-weight: bold;
      }

      .character-selection {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin: 15px 0;
        flex-wrap: wrap;
      }

      .character-option {
        padding: 10px 15px;
        font-size: 36px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        min-width: 80px;
      }

      .character-option:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
      }

      .character-option.selected {
        background: rgba(255, 165, 0, 0.4);
        border-color: orange;
        transform: scale(1.1);
        box-shadow: 0 0 15px rgba(255, 165, 0, 0.4);
      }

      .character-option .name {
        font-size: 12px;
        color: white;
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div class="game-stats">
        <div>‚è≥ Time: <span id="timeDisplay">40</span></div>
        <div>üèÜ Level: <span id="levelDisplay">1</span></div>
        <div>‚≠ê High Score: <span id="highScoreDisplay">0</span></div>
        <div id="playerStats"></div>
      </div>

      <button
        class="audio-toggle-button"
        id="audioToggleBtn"
        title="Music Settings"
      >
        üéµ
      </button>

      <div class="audio-controls" id="audioControls">
        <h3>üéµ Audio Settings</h3>
        <button id="playMusicBtn">üéµ Play Music</button>
        <div class="volume-control">
          <span>üéµ</span>
          <input type="range" id="musicVolume" min="0" max="100" value="50" />
          <span id="musicVolumeValue">50%</span>
        </div>
        <div class="volume-control">
          <span>üîä</span>
          <input type="range" id="fxVolume" min="0" max="100" value="70" />
          <span id="fxVolumeValue">70%</span>
        </div>
        <button id="muteBtn">üîá Mute All</button>
      </div>

      <div class="power-up-status" id="powerUpStatus">
        <div>Active Power-up:</div>
        <div id="powerUpName">None</div>
        <div id="powerUpTime"></div>
      </div>

      <div class="game-header-buttons">
        <button id="exitButton" class="game-header-button exit-button">
          üè† EXIT GAME
        </button>
        <button id="pauseButton" class="game-header-button pause-button">
          ‚è∏ PAUSE
        </button>
      </div>

      <div id="game">
        <div id="player1" class="sprite">üßú‚Äç‚ôÄÔ∏è</div>
        <div id="player2" class="sprite" style="display: none">üßë‚ÄçüöÄ</div>
        <div id="treasure" class="sprite">üí∞</div>
        <div id="gameover"></div>
        <div id="achievement"></div>
      </div>

      <div id="startscreen">
        <h2>üèùÔ∏è Ama Treasure Adventure üèùÔ∏è</h2>

        <div class="mode-selection">
          <button class="mode-button selected" data-mode="1">
            <span class="icon">ü§π‚Äç‚ôÇÔ∏è</span>
            <span class="label">Single Player</span>
            <span class="description">Challenge yourself in solo mode!</span>
          </button>
          <button class="mode-button" data-mode="2">
            <span class="icon">ü§∏‚Äç‚ôÇÔ∏èü§∏‚Äç‚ôÄÔ∏è</span>
            <span class="label">Two Players</span>
            <span class="description">Compete with a friend!</span>
          </button>
        </div>

        <p>Enter Player 1 name:</p>
        <input
          id="player1Name"
          type="text"
          placeholder="Player 1 name"
          value="Player 1"
        />

        <p>Choose Player 1 character:</p>
        <div id="player1Characters" class="character-selection"></div>

        <div id="player2Settings" style="display: none">
          <p>Enter Player 2 name:</p>
          <input
            id="player2Name"
            type="text"
            placeholder="Player 2 name"
            value="Player 2"
          />

          <p>Choose Player 2 character:</p>
          <div id="player2Characters" class="character-selection"></div>
        </div>

        <details id="how-to-play">
          <summary>How to Play</summary>
          <p>
            <strong>üéØ Objective:</strong> Collect treasures and avoid obstacles
            before time runs out!
          </p>
          <p>
            <strong>üéÆ Controls:</strong><br />
            - <strong>Player 1:</strong> Arrow Keys (‚Üë‚Üì‚Üê‚Üí) - Character faces
            left/right<br />
            - <strong>Player 2:</strong> WASD Keys (W=Up, A=Left, S=Down,
            D=Right) - Character faces left/right<br />
            - <strong>ESC Key:</strong> Pause/Resume game anytime
          </p>
          <p>
            <strong>üé≠ Characters:</strong><br />
            Choose from Mermaid, Astronaut, Pirate, Ninja, Explorer, Diver,
            Sailor, or Viking!<br />
            Characters face the direction they move (left/right only)
          </p>
          <p>
            <strong>üí∞ Treasures:</strong><br />
            - üí∞ Coins (1 point) - Common<br />
            - ‚ö™ Silver (3 points) - Uncommon<br />
            - üåü Gold (5 points) - Rare<br />
            - üíé Gems (10 points) - Very Rare
          </p>
          <p>
            <strong>‚ö° Power-ups (Level 3+):</strong><br />
            - üß≤ Magnet: Pulls treasures closer<br />
            - ‚ö° Speed: Move faster temporarily<br />
            - üõ°Ô∏è Shield: Temporary invincibility<br />
            - ‚ú® Points: Double points for duration
          </p>
          <p>
            <strong>üåä Dynamic Obstacles:</strong><br />
            - üêä Crocodiles face their movement direction and track players<br />
            - üî• Fire and ü•• Coconuts move randomly<br />
            - Obstacles respawn randomly when treasures are collected!
          </p>
          <p>
            <strong>üéµ Audio Controls:</strong><br />
            - Click the üéµ button (top-right) to open/close music settings<br />
            - Adjust music and sound effects volumes independently<br />
            - Play/pause music and mute all sounds
          </p>
          <p>
            <strong>üéÅ Bonuses:</strong><br />
            - Level up every 5 points (+10 seconds)<br />
            - Time bonus at 15+ points (+5 seconds per 5 points)<br />
            - Bonus life at Level 6
          </p>
        </details>

        <button onclick="startGame()">üöÄ Play Game</button>
      </div>

      <div class="game-title">AMA TREASURE ADVENTURE</div>
    </div>

    <!-- Audio Elements -->
    <audio id="backgroundMusic" loop preload="auto">
      <source src="data/audio/background.mp3" type="audio/mpeg" />
      <source src="data/Game-Night-Groove-1.mp3" type="audio/mpeg" />
    </audio>
    <audio id="treasureSound" preload="auto">
      <source src="data/audio/treasure.mp3" type="audio/mpeg" />
    </audio>
    <audio id="powerupSound" preload="auto">
      <source src="data/audio/powerup.mp3" type="audio/mpeg" />
    </audio>
    <audio id="obstacleSound" preload="auto">
      <source src="data/audio/obstacle.mp3" type="audio/mpeg" />
    </audio>
    <audio id="achievementSound" preload="auto">
      <source src="data/audio/achievement.mp3" type="audio/mpeg" />
    </audio>
    <audio id="gameoverSound" preload="auto">
      <source src="data/audio/gameover.mp3" type="audio/mpeg" />
    </audio>
    <audio id="menuClickSound" preload="auto">
      <source src="data/audio/menu_click.mp3" type="audio/mpeg" />
    </audio>

    <script>
      // Game Elements
      const player1 = document.getElementById("player1");
      const player2 = document.getElementById("player2");
      const treasure = document.getElementById("treasure");
      const gameover = document.getElementById("gameover");
      const startscreen = document.getElementById("startscreen");
      const achievement = document.getElementById("achievement");
      const gameContainer = document.getElementById("game");
      const powerUpStatus = document.getElementById("powerUpStatus");

      // Game State
      let obstacles = [];
      let powerUps = [];
      let mode = 1;
      let player1Name = "Player 1";
      let player2Name = "Player 2";
      let p1Score = 0,
        p2Score = 0;
      let p1Lives = 3,
        p2Lives = 3;
      let timeLeft = 40;
      let level = 1;
      let timer;
      let p1X = 100,
        p1Y = 100;
      let p2X = 200,
        p2Y = 200;
      const moveStep = 20;
      let highScore = localStorage.getItem("treasureHighScore") || 0;

      // Character selection and facing direction
      let selectedP1Character = "MERMAID";
      let selectedP2Character = "RUNNER";
      let p1FacingLeft = false;
      let p2FacingLeft = false;

      // Power-up system
      let activePowerUps = {
        player1: null,
        player2: null,
      };

      // Audio System using HTML5 Audio Elements
      let musicVolume = 0.5;
      let fxVolume = 0.7;
      let isMuted = false;
      let isPlaying = false;

      // Audio elements
      const backgroundMusic = document.getElementById("backgroundMusic");
      const treasureSound = document.getElementById("treasureSound");
      const powerupSound = document.getElementById("powerupSound");
      const obstacleSound = document.getElementById("obstacleSound");
      const achievementSound = document.getElementById("achievementSound");
      const gameoverSound = document.getElementById("gameoverSound");
      const menuClickSound = document.getElementById("menuClickSound");

      // Character options for players - Directional characters with clear left/right facing
      const characterOptions = {
        MERMAID: { emoji: "üßú‚Äç‚ôÄÔ∏è", name: "Mermaid" },
        RUNNER: { emoji: "üèÉ‚Äç‚ôÇÔ∏è", name: "Runner" },
        FISH: { emoji: "üêü", name: "Fish" },
        CAR: { emoji: "üöó", name: "Car" },
        HORSE: { emoji: "üêé", name: "Horse" },
        SURFER: { emoji: "üèÑ‚Äç‚ôÇÔ∏è", name: "Surfer" },
      };

      const treasureTypes = {
        COIN: { emoji: "üí∞", points: 1, rarity: 0.6 },
        SILVER: { emoji: "‚ö™", points: 3, rarity: 0.25 },
        GOLD: { emoji: "üåü", points: 5, rarity: 0.1 },
        GEM: { emoji: "üíé", points: 10, rarity: 0.05 },
      };

      const powerUpTypes = {
        MAGNET: {
          emoji: "üß≤",
          duration: 6,
          effect: "Attract Treasures",
          minLevel: 3,
        },
        SPEED: { emoji: "‚ö°", duration: 5, effect: "2x Speed", minLevel: 3 },
        SHIELD: {
          emoji: "üõ°Ô∏è",
          duration: 8,
          effect: "Temporary Invincibility",
          minLevel: 4,
        },
        POINTS: { emoji: "‚ú®", duration: 7, effect: "2x Points", minLevel: 4 },
      };

      // Initialize audio system
      function initAudio() {
        // Set initial volumes
        updateAudioVolumes();

        // Enable user interaction for audio autoplay
        backgroundMusic.volume = musicVolume;
        console.log("Audio system initialized with MP3 files");
      }

      // Update all audio volumes
      function updateAudioVolumes() {
        if (backgroundMusic) backgroundMusic.volume = isMuted ? 0 : musicVolume;
        if (treasureSound) treasureSound.volume = isMuted ? 0 : fxVolume;
        if (powerupSound) powerupSound.volume = isMuted ? 0 : fxVolume;
        if (obstacleSound) obstacleSound.volume = isMuted ? 0 : fxVolume;
        if (achievementSound) achievementSound.volume = isMuted ? 0 : fxVolume;
        if (gameoverSound) gameoverSound.volume = isMuted ? 0 : fxVolume;
        if (menuClickSound) menuClickSound.volume = isMuted ? 0 : fxVolume;
      }

      // Play specific sound effect
      function playAudio(audioElement) {
        if (!audioElement || isMuted) return;

        try {
          audioElement.currentTime = 0; // Reset to start
          audioElement.play().catch((e) => {
            console.log("Audio play failed:", e.message);
          });
        } catch (e) {
          console.log("Audio error:", e);
        }
      }

      // Background music controls
      function startBackgroundMusic() {
        if (!backgroundMusic || isMuted) return;

        try {
          backgroundMusic.currentTime = 0;
          backgroundMusic
            .play()
            .then(() => {
              isPlaying = true;
              console.log("Background music started");
            })
            .catch((e) => {
              console.log("Background music failed to start:", e.message);
              // Fall back to procedural music if MP3 fails
              fallbackToProceduralMusic();
            });
        } catch (e) {
          console.log("Background music error:", e);
          fallbackToProceduralMusic();
        }
      }

      function stopBackgroundMusic() {
        if (backgroundMusic) {
          backgroundMusic.pause();
          backgroundMusic.currentTime = 0;
        }
        isPlaying = false;

        // Also stop procedural music if it's running
        if (musicInterval) {
          clearInterval(musicInterval);
          musicInterval = null;
        }
      }

      // Fallback procedural music system
      let audioContext = null;
      let musicInterval = null;

      function fallbackToProceduralMusic() {
        console.log("Falling back to procedural music");

        if (!audioContext) {
          try {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          } catch (e) {
            console.log("Web Audio API not supported");
            return;
          }
        }

        if (musicInterval || isMuted) return;

        const notes = [261.63, 293.66, 329.63, 349.23, 392.0, 440.0, 493.88];
        let noteIndex = 0;

        musicInterval = setInterval(() => {
          if (!isMuted && isPlaying) {
            try {
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();

              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);

              oscillator.frequency.setValueAtTime(
                notes[noteIndex],
                audioContext.currentTime
              );
              oscillator.type = "triangle";

              gainNode.gain.setValueAtTime(
                musicVolume * 0.1,
                audioContext.currentTime
              );
              gainNode.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + 0.3
              );

              oscillator.start(audioContext.currentTime);
              oscillator.stop(audioContext.currentTime + 0.3);

              noteIndex = (noteIndex + 1) % notes.length;
            } catch (e) {
              console.log("Procedural music error:", e);
            }
          }
        }, 800);
      }

      // Audio controls
      document.getElementById("playMusicBtn").addEventListener("click", () => {
        initAudio();

        const btn = document.getElementById("playMusicBtn");

        if (!isPlaying) {
          startBackgroundMusic();
          btn.textContent = "‚è∏ Pause Music";
        } else {
          stopBackgroundMusic();
          btn.textContent = "üéµ Play Music";
        }
      });

      document.getElementById("musicVolume").addEventListener("input", (e) => {
        musicVolume = e.target.value / 100;
        document.getElementById("musicVolumeValue").textContent =
          e.target.value + "%";
        updateAudioVolumes();
      });

      document.getElementById("fxVolume").addEventListener("input", (e) => {
        fxVolume = e.target.value / 100;
        document.getElementById("fxVolumeValue").textContent =
          e.target.value + "%";
        updateAudioVolumes();
      });

      document.getElementById("muteBtn").addEventListener("click", () => {
        isMuted = !isMuted;
        const btn = document.getElementById("muteBtn");
        btn.textContent = isMuted ? "üîä Unmute" : "üîá Mute All";

        updateAudioVolumes();

        if (isMuted) {
          stopBackgroundMusic();
        } else if (isPlaying) {
          startBackgroundMusic();
        }
      });

      // Audio panel toggle functionality
      let audioControlsExpanded = false;

      document
        .getElementById("audioToggleBtn")
        .addEventListener("click", () => {
          const audioControls = document.getElementById("audioControls");
          const toggleBtn = document.getElementById("audioToggleBtn");

          audioControlsExpanded = !audioControlsExpanded;

          if (audioControlsExpanded) {
            audioControls.classList.add("expanded");
            toggleBtn.classList.add("active");
            toggleBtn.innerHTML = "üé∂";
          } else {
            audioControls.classList.remove("expanded");
            toggleBtn.classList.remove("active");
            toggleBtn.innerHTML = "üéµ";
          }

          playAudio(menuClickSound);
        });

      // Close audio controls when clicking outside
      document.addEventListener("click", (e) => {
        const audioControls = document.getElementById("audioControls");
        const toggleBtn = document.getElementById("audioToggleBtn");

        if (
          audioControlsExpanded &&
          !audioControls.contains(e.target) &&
          !toggleBtn.contains(e.target)
        ) {
          audioControls.classList.remove("expanded");
          toggleBtn.classList.remove("active");
          toggleBtn.innerHTML = "üéµ";
          audioControlsExpanded = false;
        }
      });

      // Initialize character selection
      function initializeCharacterSelection() {
        const p1Container = document.getElementById("player1Characters");
        const p2Container = document.getElementById("player2Characters");

        // Clear existing characters
        p1Container.innerHTML = "";
        p2Container.innerHTML = "";

        // Create character options for both players
        Object.entries(characterOptions).forEach(([key, character]) => {
          // Player 1 character option
          const p1Option = document.createElement("div");
          p1Option.className = "character-option";
          if (key === selectedP1Character) p1Option.classList.add("selected");
          p1Option.innerHTML = `
             <div class="emoji">${character.emoji}</div>
             <div class="name">${character.name}</div>
           `;
          p1Option.addEventListener("click", () => {
            selectedP1Character = key;
            updateCharacterSelection("player1");
            playAudio(menuClickSound);
          });
          p1Container.appendChild(p1Option);

          // Player 2 character option
          const p2Option = document.createElement("div");
          p2Option.className = "character-option";
          if (key === selectedP2Character) p2Option.classList.add("selected");
          p2Option.innerHTML = `
             <div class="emoji">${character.emoji}</div>
             <div class="name">${character.name}</div>
           `;
          p2Option.addEventListener("click", () => {
            selectedP2Character = key;
            updateCharacterSelection("player2");
            playAudio(menuClickSound);
          });
          p2Container.appendChild(p2Option);
        });
      }

      function updateCharacterSelection(player) {
        const container = document.getElementById(
          player === "player1" ? "player1Characters" : "player2Characters"
        );
        const selectedChar =
          player === "player1" ? selectedP1Character : selectedP2Character;

        container
          .querySelectorAll(".character-option")
          .forEach((option, index) => {
            const characterKey = Object.keys(characterOptions)[index];
            if (characterKey === selectedChar) {
              option.classList.add("selected");
            } else {
              option.classList.remove("selected");
            }
          });
      }

      // Update player appearance based on selection and facing direction
      function updatePlayerAppearance() {
        const p1Char = characterOptions[selectedP1Character];
        const p2Char = characterOptions[selectedP2Character];

        // Simple facing logic - just use the character emoji
        // Most emojis don't have left/right variants, so we keep them as-is
        player1.innerText = p1Char.emoji;
        player2.innerText = p2Char.emoji;

        // Add visual indicator for facing direction with CSS transform
        player1.style.transform = p1FacingLeft ? "scaleX(-1)" : "scaleX(1)";
        player2.style.transform = p2FacingLeft ? "scaleX(-1)" : "scaleX(1)";
      }

      // Initialize game
      function init() {
        console.log("Initializing game...");

        // Show start screen
        startscreen.style.display = "block";
        player1.style.display = "none";
        player2.style.display = "none";
        treasure.style.display = "none";
        document.querySelector(".game-header-buttons").style.display = "none";
        powerUpStatus.style.display = "none";

        // Update high score display
        document.getElementById("highScoreDisplay").textContent = highScore;

        // Initialize character selection
        initializeCharacterSelection();

        // Mode selection
        document.querySelectorAll(".mode-button").forEach((button) => {
          button.addEventListener("click", () => {
            document
              .querySelectorAll(".mode-button")
              .forEach((b) => b.classList.remove("selected"));
            button.classList.add("selected");
            mode = parseInt(button.dataset.mode);
            playAudio(menuClickSound); // Click sound

            const player2Settings = document.getElementById("player2Settings");
            if (mode === 2) {
              player2Settings.style.display = "block";
            } else {
              player2Settings.style.display = "none";
            }
          });
        });

        console.log("Game initialized");
      }

      function randomPosition() {
        const game = document.getElementById("game");
        const x = Math.random() * (game.clientWidth - 60);
        const y = Math.random() * (game.clientHeight - 60);
        return { x, y };
      }

      function placeTreasure() {
        // Select random treasure type based on rarity
        const rand = Math.random();
        let selectedType = treasureTypes.COIN;
        let cumulative = 0;

        for (const type of Object.values(treasureTypes)) {
          cumulative += type.rarity;
          if (rand <= cumulative) {
            selectedType = type;
            break;
          }
        }

        treasure.innerText = selectedType.emoji;
        treasure.dataset.points = selectedType.points;
        treasure.dataset.type = Object.keys(treasureTypes).find(
          (key) => treasureTypes[key] === selectedType
        );

        const pos = randomPosition();
        treasure.style.left = pos.x + "px";
        treasure.style.top = pos.y + "px";
      }

      function createPowerUp() {
        if (level < 3) return; // Power-ups only appear from level 3+
        if (powerUps.length >= 2) return; // Max 2 power-ups at once
        if (Math.random() > 0.3) return; // 30% chance

        const availablePowerUps = Object.entries(powerUpTypes).filter(
          ([_, type]) => level >= type.minLevel
        );
        if (availablePowerUps.length === 0) return;

        const [powerUpName, powerUpType] =
          availablePowerUps[
            Math.floor(Math.random() * availablePowerUps.length)
          ];

        const powerUp = document.createElement("div");
        powerUp.className = "power-up sprite";
        powerUp.innerText = powerUpType.emoji;
        powerUp.dataset.type = powerUpName;

        const pos = randomPosition();
        powerUp.style.left = pos.x + "px";
        powerUp.style.top = pos.y + "px";

        gameContainer.appendChild(powerUp);
        powerUps.push(powerUp);

        // Remove power-up after 10 seconds
        setTimeout(() => {
          if (powerUps.includes(powerUp)) {
            powerUp.remove();
            powerUps = powerUps.filter((p) => p !== powerUp);
          }
        }, 10000);
      }

      function createObstacles() {
        // Clear existing obstacles
        obstacles.forEach((obs) => obs.remove());
        obstacles = [];

        const obstacleTypes = [
          { emoji: "üêä", type: "crocodile", faceable: true },
          { emoji: "üî•", type: "fire", faceable: false },
          { emoji: "ü••", type: "coconut", faceable: false },
        ];
        let obstacleCount = 2;

        if (level >= 13) obstacleCount = 8;
        else if (level >= 9) obstacleCount = 6;
        else if (level >= 6) obstacleCount = 5;
        else if (level >= 4) obstacleCount = 4;
        else if (level >= 3) obstacleCount = 3;

        for (let i = 0; i < obstacleCount; i++) {
          const obs = document.createElement("div");
          obs.className = "obstacle sprite";

          const selectedObstacle =
            obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
          obs.innerText = selectedObstacle.emoji;
          obs.dataset.type = selectedObstacle.type;
          obs.dataset.faceable = selectedObstacle.faceable;

          const pos = randomPosition();
          obs.style.left = pos.x + "px";
          obs.style.top = pos.y + "px";

          // Set movement direction and speed
          const dx = (Math.random() - 0.5) * (2 + level * 0.5);
          const dy = (Math.random() - 0.5) * (2 + level * 0.5);
          obs.dataset.dx = dx;
          obs.dataset.dy = dy;

          // Set initial facing direction for crocodiles
          if (selectedObstacle.faceable) {
            obs.dataset.facingLeft = dx < 0 ? "true" : "false";
            obs.style.transform = dx < 0 ? "scaleX(-1)" : "scaleX(1)";
          }

          gameContainer.appendChild(obs);
          obstacles.push(obs);
        }
      }

      // Random obstacle respawn when treasure is collected
      function randomObstacleRespawn() {
        if (obstacles.length === 0) return;

        // Randomly remove 1-2 obstacles
        const removeCount = Math.min(
          Math.floor(Math.random() * 2) + 1,
          obstacles.length
        );

        for (let i = 0; i < removeCount; i++) {
          const randomIndex = Math.floor(Math.random() * obstacles.length);
          const obstacleToRemove = obstacles[randomIndex];
          obstacleToRemove.remove();
          obstacles.splice(randomIndex, 1);
        }

        // Add new obstacles at random positions
        const obstacleTypes = [
          { emoji: "üêä", type: "crocodile", faceable: true },
          { emoji: "üî•", type: "fire", faceable: false },
          { emoji: "ü••", type: "coconut", faceable: false },
        ];

        for (let i = 0; i < removeCount; i++) {
          const obs = document.createElement("div");
          obs.className = "obstacle sprite";

          const selectedObstacle =
            obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
          obs.innerText = selectedObstacle.emoji;
          obs.dataset.type = selectedObstacle.type;
          obs.dataset.faceable = selectedObstacle.faceable;

          const pos = randomPosition();
          obs.style.left = pos.x + "px";
          obs.style.top = pos.y + "px";

          // Set movement direction and speed
          const dx = (Math.random() - 0.5) * (2 + level * 0.5);
          const dy = (Math.random() - 0.5) * (2 + level * 0.5);
          obs.dataset.dx = dx;
          obs.dataset.dy = dy;

          // Set initial facing direction for crocodiles
          if (selectedObstacle.faceable) {
            obs.dataset.facingLeft = dx < 0 ? "true" : "false";
            obs.style.transform = dx < 0 ? "scaleX(-1)" : "scaleX(1)";
          }

          gameContainer.appendChild(obs);
          obstacles.push(obs);
        }
      }

      function moveObstacles() {
        obstacles.forEach((obs) => {
          let currentLeft = parseFloat(obs.style.left);
          let currentTop = parseFloat(obs.style.top);
          let dx = parseFloat(obs.dataset.dx);
          let dy = parseFloat(obs.dataset.dy);
          let oldDx = dx; // Store original dx to check for direction change

          // Enhanced movement for level 3+
          if (level >= 3) {
            // Add some tracking behavior towards players
            const player =
              mode === 2 ? (Math.random() < 0.5 ? player1 : player2) : player1;
            const playerRect = player.getBoundingClientRect();
            const obsRect = obs.getBoundingClientRect();

            const distanceToPlayer = Math.sqrt(
              Math.pow(playerRect.left - obsRect.left, 2) +
                Math.pow(playerRect.top - obsRect.top, 2)
            );

            if (distanceToPlayer < 200) {
              const attraction = 0.1 + (level - 3) * 0.05;
              dx +=
                ((playerRect.left - obsRect.left) * attraction) /
                distanceToPlayer;
              dy +=
                ((playerRect.top - obsRect.top) * attraction) /
                distanceToPlayer;
            }
          }

          // Move obstacle
          currentLeft += dx;
          currentTop += dy;

          // Bounce off walls and update facing direction
          if (
            currentLeft <= 0 ||
            currentLeft >= gameContainer.clientWidth - 60
          ) {
            dx = -dx;
            obs.dataset.dx = dx;
          }
          if (
            currentTop <= 0 ||
            currentTop >= gameContainer.clientHeight - 60
          ) {
            dy = -dy;
            obs.dataset.dy = dy;
          }

          // Update facing direction for faceable obstacles (like crocodiles)
          if (obs.dataset.faceable === "true") {
            const newFacingLeft = dx < 0;
            const currentFacingLeft = obs.dataset.facingLeft === "true";

            if (newFacingLeft !== currentFacingLeft) {
              obs.dataset.facingLeft = newFacingLeft ? "true" : "false";
              obs.style.transform = newFacingLeft ? "scaleX(-1)" : "scaleX(1)";
            }
          }

          // Keep in bounds
          currentLeft = Math.max(
            0,
            Math.min(gameContainer.clientWidth - 60, currentLeft)
          );
          currentTop = Math.max(
            0,
            Math.min(gameContainer.clientHeight - 60, currentTop)
          );

          obs.style.left = currentLeft + "px";
          obs.style.top = currentTop + "px";
        });
      }

      function applyMagnetEffect(player) {
        if (
          !activePowerUps[player === player1 ? "player1" : "player2"] ||
          activePowerUps[player === player1 ? "player1" : "player2"].type !==
            "MAGNET"
        )
          return;

        const playerRect = player.getBoundingClientRect();
        const treasureRect = treasure.getBoundingClientRect();

        const dx = playerRect.left - treasureRect.left;
        const dy = playerRect.top - treasureRect.top;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 150) {
          // Magnet range
          const speed = 3;
          const moveX = (dx / distance) * speed;
          const moveY = (dy / distance) * speed;

          const currentLeft = parseFloat(treasure.style.left);
          const currentTop = parseFloat(treasure.style.top);
          treasure.style.left = currentLeft + moveX + "px";
          treasure.style.top = currentTop + moveY + "px";

          // Add visual effect
          if (!treasure.classList.contains("magnet-active")) {
            treasure.classList.add("magnet-active");
          }
        } else {
          treasure.classList.remove("magnet-active");
        }
      }

      function activatePowerUp(player, powerUpType) {
        const playerKey = player === player1 ? "player1" : "player2";
        const playerName = player === player1 ? player1Name : player2Name;

        // Clear existing power-up
        if (activePowerUps[playerKey]) {
          clearTimeout(activePowerUps[playerKey].timeout);
        }

        activePowerUps[playerKey] = {
          type: powerUpType,
          duration: powerUpTypes[powerUpType].duration,
        };

        playAudio(powerupSound); // Power-up sound
        showMessage(
          `‚ö° ${playerName} got ${powerUpTypes[powerUpType].effect}!`
        );

        // Update power-up status display
        updatePowerUpDisplay();

        // Set timeout to deactivate
        activePowerUps[playerKey].timeout = setTimeout(() => {
          activePowerUps[playerKey] = null;
          updatePowerUpDisplay();
          showMessage(`‚è∞ ${playerName}'s power-up expired`);
        }, powerUpTypes[powerUpType].duration * 1000);
      }

      function updatePowerUpDisplay() {
        const p1PowerUp = activePowerUps.player1;
        const p2PowerUp = activePowerUps.player2;

        if (p1PowerUp || p2PowerUp) {
          powerUpStatus.style.display = "block";
          let statusText = "";

          if (p1PowerUp) {
            statusText += `${player1Name}: ${
              powerUpTypes[p1PowerUp.type].emoji
            } ${powerUpTypes[p1PowerUp.type].effect}`;
          }
          if (p2PowerUp) {
            if (statusText) statusText += "<br>";
            statusText += `${player2Name}: ${
              powerUpTypes[p2PowerUp.type].emoji
            } ${powerUpTypes[p2PowerUp.type].effect}`;
          }

          document.getElementById("powerUpName").innerHTML = statusText;
        } else {
          powerUpStatus.style.display = "none";
        }
      }

      function checkCollisions() {
        const p1Rect = player1.getBoundingClientRect();
        const treasureRect = treasure.getBoundingClientRect();

        // Check treasure collision for player 1
        if (isOverlapping(p1Rect, treasureRect)) {
          const points = parseInt(treasure.dataset.points) || 1;
          const multiplier =
            activePowerUps.player1 && activePowerUps.player1.type === "POINTS"
              ? 2
              : 1;
          p1Score += points * multiplier;

          placeTreasure();
          randomObstacleRespawn(); // Trigger random obstacle respawn
          playAudio(treasureSound); // Treasure sound
          showMessage(
            `üí∞ ${player1Name} collected ${treasure.dataset.type}! +${
              points * multiplier
            } points`
          );

          if (p1Score % 5 === 0) {
            levelUp();
          }
        }

        // Check treasure collision for player 2
        if (mode === 2) {
          const p2Rect = player2.getBoundingClientRect();
          if (isOverlapping(p2Rect, treasureRect)) {
            const points = parseInt(treasure.dataset.points) || 1;
            const multiplier =
              activePowerUps.player2 && activePowerUps.player2.type === "POINTS"
                ? 2
                : 1;
            p2Score += points * multiplier;

            placeTreasure();
            randomObstacleRespawn(); // Trigger random obstacle respawn
            playAudio(treasureSound);
            showMessage(
              `üí∞ ${player2Name} collected ${treasure.dataset.type}! +${
                points * multiplier
              } points`
            );

            if (p2Score % 5 === 0) {
              levelUp();
            }
          }
        }

        // Check power-up collisions
        powerUps.forEach((powerUp, index) => {
          const powerUpRect = powerUp.getBoundingClientRect();

          if (isOverlapping(p1Rect, powerUpRect)) {
            activatePowerUp(player1, powerUp.dataset.type);
            powerUp.remove();
            powerUps.splice(index, 1);
          } else if (mode === 2) {
            const p2Rect = player2.getBoundingClientRect();
            if (isOverlapping(p2Rect, powerUpRect)) {
              activatePowerUp(player2, powerUp.dataset.type);
              powerUp.remove();
              powerUps.splice(index, 1);
            }
          }
        });

        // Check obstacle collisions
        obstacles.forEach((obs) => {
          const obsRect = obs.getBoundingClientRect();

          if (
            isOverlapping(p1Rect, obsRect) &&
            !(
              activePowerUps.player1 && activePowerUps.player1.type === "SHIELD"
            )
          ) {
            p1Lives--;
            playAudio(obstacleSound); // Hit sound
            showMessage(`üí• ${player1Name} hit obstacle! Lives: ${p1Lives}`);

            if (p1Lives <= 0 && (mode === 1 || p2Lives <= 0)) {
              endGame();
            }
          }

          if (mode === 2) {
            const p2Rect = player2.getBoundingClientRect();
            if (
              isOverlapping(p2Rect, obsRect) &&
              !(
                activePowerUps.player2 &&
                activePowerUps.player2.type === "SHIELD"
              )
            ) {
              p2Lives--;
              playAudio(obstacleSound);
              showMessage(`üí• ${player2Name} hit obstacle! Lives: ${p2Lives}`);

              if (p2Lives <= 0 && p1Lives <= 0) {
                endGame();
              }
            }
          }
        });
      }

      function isOverlapping(rect1, rect2) {
        return !(
          rect1.top > rect2.bottom ||
          rect1.bottom < rect2.top ||
          rect1.left > rect2.right ||
          rect1.right < rect2.left
        );
      }

      function updateDisplay() {
        document.getElementById("timeDisplay").textContent = timeLeft;
        document.getElementById("levelDisplay").textContent = level;
        document.getElementById("highScoreDisplay").textContent = highScore;

        let statsHtml = `${player1Name}: ${p1Score} points ‚ù§Ô∏è ${p1Lives} lives`;
        if (mode === 2) {
          statsHtml += `<br>${player2Name}: ${p2Score} points ‚ù§Ô∏è ${p2Lives} lives`;
        }
        document.getElementById("playerStats").innerHTML = statsHtml;
      }

      function showMessage(text) {
        achievement.innerText = text;
        achievement.style.display = "block";
        setTimeout(() => (achievement.style.display = "none"), 2500);
      }

      function levelUp() {
        level++;
        timeLeft += 10;

        if (level === 6) {
          p1Lives++;
          if (mode === 2) p2Lives++;
          showMessage("üíñ Bonus Life! +1 life added!");
        }

        createObstacles();
        playAudio(achievementSound); // Level up sound
        showMessage(`üéâ Level ${level}! +10 seconds!`);

        // Chance to spawn power-up on level up
        if (level >= 3 && Math.random() < 0.7) {
          setTimeout(createPowerUp, 1000);
        }
      }

      function gameTick() {
        if (timeLeft > 0 && (p1Lives > 0 || (mode === 2 && p2Lives > 0))) {
          timeLeft--;
          moveObstacles();

          // Apply magnet effects
          applyMagnetEffect(player1);
          if (mode === 2) applyMagnetEffect(player2);

          updateDisplay();

          // Spawn power-ups occasionally
          if (Math.random() < 0.02) {
            // 2% chance per second
            createPowerUp();
          }
        } else {
          endGame();
        }
      }

      function startGame() {
        console.log("Starting game...");
        initAudio();

        mode = parseInt(
          document.querySelector(".mode-button.selected").dataset.mode
        );
        player1Name =
          document.getElementById("player1Name").value || "Player 1";
        player2Name =
          document.getElementById("player2Name").value || "Player 2";

        // Reset game state
        p1Score = 0;
        p2Score = 0;
        p1Lives = 3;
        p2Lives = 3;
        timeLeft = 40;
        level = 1;
        p1X = 100;
        p1Y = 100;
        p2X = 200;
        p2Y = 200;

        // Clear power-ups
        activePowerUps = { player1: null, player2: null };
        powerUps.forEach((p) => p.remove());
        powerUps = [];

        // Show game elements
        startscreen.style.display = "none";
        gameover.style.display = "none"; // Hide game over dialog
        player1.style.display = "block";
        treasure.style.display = "block";
        document.querySelector(".game-header-buttons").style.display = "flex";

        // Reset pause button to initial state
        const pauseBtn = document.getElementById("pauseButton");
        pauseBtn.innerHTML = "‚è∏ PAUSE";
        pauseBtn.style.background = "rgba(255, 193, 7, 0.8)";

        if (mode === 2) {
          player2.style.display = "block";
        } else {
          player2.style.display = "none";
        }

        // Position players
        player1.style.left = p1X + "px";
        player1.style.top = p1Y + "px";
        player2.style.left = p2X + "px";
        player2.style.top = p2Y + "px";

        // Update player appearances based on selection
        updatePlayerAppearance();

        // Place treasure and obstacles
        placeTreasure();
        createObstacles();

        // Update display
        updateDisplay();

        // Start game timer
        clearInterval(timer);
        timer = setInterval(gameTick, 1000);

        console.log("Game started successfully");
      }

      function endGame() {
        clearInterval(timer);
        if (movementInterval) {
          clearInterval(movementInterval);
          movementInterval = null;
        }
        keysPressed.clear();
        stopBackgroundMusic();

        let message = `Game Over!<br>${player1Name}: ${p1Score} points`;
        if (mode === 2) {
          message += `<br>${player2Name}: ${p2Score} points`;
          const winner =
            p1Score > p2Score
              ? player1Name
              : p2Score > p1Score
              ? player2Name
              : "Tie";
          message += `<br><strong>Winner: ${winner}</strong>`;
        }

        const bestScore = Math.max(p1Score, p2Score || 0);
        if (bestScore > highScore) {
          highScore = bestScore;
          localStorage.setItem("treasureHighScore", highScore);
          message += "<br>üéâ NEW HIGH SCORE!";
        }

        playAudio(gameoverSound); // Game over sound

        gameover.style.display = "block";
        gameover.innerHTML = `
        ${message}<br><br>
        <button onclick="startGame()">üîÑ Play Again</button>
        <button onclick="backToMenu()">üè† Main Menu</button>
      `;
      }

      function backToMenu() {
        clearInterval(timer);
        if (movementInterval) {
          clearInterval(movementInterval);
          movementInterval = null;
        }
        keysPressed.clear();
        stopBackgroundMusic();

        player1.style.display = "none";
        player2.style.display = "none";
        treasure.style.display = "none";
        document.querySelector(".game-header-buttons").style.display = "none";
        powerUpStatus.style.display = "none";
        gameover.style.display = "none";

        obstacles.forEach((obs) => obs.remove());
        obstacles = [];
        powerUps.forEach((p) => p.remove());
        powerUps = [];

        startscreen.style.display = "block";
      }

      // Exit game function - returns to start screen
      function exitGame() {
        // Show confirmation dialog
        if (
          confirm(
            "Are you sure you want to exit the game? Your progress will be lost."
          )
        ) {
          playAudio(menuClickSound);
          backToMenu();
        }
      }

      // Key state tracking for simultaneous movement
      const keysPressed = new Set();
      let movementInterval = null;

      // Track key press states
      document.addEventListener("keydown", (e) => {
        keysPressed.add(e.key.toLowerCase());

        // Handle non-movement keys immediately
        if (e.key === "Escape") {
          const pauseBtn = document.getElementById("pauseButton");

          if (timer) {
            clearInterval(timer);
            timer = null;
            pauseBtn.innerHTML = "‚ñ∂ RESUME";
            pauseBtn.style.background = "rgba(40, 167, 69, 0.8)";
            showMessage("‚è∏ Game Paused - Press ESC to resume");
          } else {
            timer = setInterval(gameTick, 1000);
            pauseBtn.innerHTML = "‚è∏ PAUSE";
            pauseBtn.style.background = "rgba(255, 193, 7, 0.8)";
            showMessage("‚ñ∂ Game Resumed");
          }
          return;
        }

        // Start movement processing if not already running
        if (!movementInterval) {
          movementInterval = setInterval(processMovement, 16); // ~60fps
        }
      });

      document.addEventListener("keyup", (e) => {
        keysPressed.delete(e.key.toLowerCase());

        // Stop movement processing if no movement keys are pressed
        const movementKeys = [
          "arrowright",
          "arrowleft",
          "arrowup",
          "arrowdown",
          "w",
          "a",
          "s",
          "d",
        ];
        const hasMovementKeys = movementKeys.some((key) =>
          keysPressed.has(key)
        );

        if (!hasMovementKeys && movementInterval) {
          clearInterval(movementInterval);
          movementInterval = null;
        }
      });

      // Process movement for both players simultaneously
      function processMovement() {
        if ((p1Lives <= 0 && (mode === 1 || p2Lives <= 0)) || timeLeft <= 0) {
          if (movementInterval) {
            clearInterval(movementInterval);
            movementInterval = null;
          }
          return;
        }

        const speedMultiplier =
          activePowerUps.player1 && activePowerUps.player1.type === "SPEED"
            ? 2
            : 1;
        const speedMultiplier2 =
          activePowerUps.player2 && activePowerUps.player2.type === "SPEED"
            ? 2
            : 1;

        let moved = false;

        // Player 1 movement (Arrow Keys) - can process multiple simultaneously
        if (keysPressed.has("arrowright")) {
          p1X += moveStep * speedMultiplier;
          p1FacingLeft = false;
          moved = true;
        }
        if (keysPressed.has("arrowleft")) {
          p1X -= moveStep * speedMultiplier;
          p1FacingLeft = true;
          moved = true;
        }
        if (keysPressed.has("arrowup")) {
          p1Y -= moveStep * speedMultiplier;
          moved = true;
        }
        if (keysPressed.has("arrowdown")) {
          p1Y += moveStep * speedMultiplier;
          moved = true;
        }

        // Player 2 movement (WASD Keys) - can process multiple simultaneously
        if (mode === 2) {
          if (keysPressed.has("d")) {
            p2X += moveStep * speedMultiplier2;
            p2FacingLeft = false;
            moved = true;
          }
          if (keysPressed.has("a")) {
            p2X -= moveStep * speedMultiplier2;
            p2FacingLeft = true;
            moved = true;
          }
          if (keysPressed.has("w")) {
            p2Y -= moveStep * speedMultiplier2;
            moved = true;
          }
          if (keysPressed.has("s")) {
            p2Y += moveStep * speedMultiplier2;
            moved = true;
          }
        }

        if (moved) {
          // Keep players in bounds with smooth screen wrapping
          const game = document.getElementById("game");
          let p1Wrapped = false;
          let p2Wrapped = false;

          // Player 1 screen wrapping with smooth transition
          if (p1X < -30) {
            p1X = game.clientWidth - 30;
            p1Wrapped = true;
          } else if (p1X > game.clientWidth - 30) {
            p1X = -30;
            p1Wrapped = true;
          }
          if (p1Y < -30) {
            p1Y = game.clientHeight - 30;
            p1Wrapped = true;
          } else if (p1Y > game.clientHeight - 30) {
            p1Y = -30;
            p1Wrapped = true;
          }

          // Player 2 screen wrapping with smooth transition
          if (mode === 2) {
            if (p2X < -30) {
              p2X = game.clientWidth - 30;
              p2Wrapped = true;
            } else if (p2X > game.clientWidth - 30) {
              p2X = -30;
              p2Wrapped = true;
            }
            if (p2Y < -30) {
              p2Y = game.clientHeight - 30;
              p2Wrapped = true;
            } else if (p2Y > game.clientHeight - 30) {
              p2Y = -30;
              p2Wrapped = true;
            }
          }

          // Apply smooth wrapping effect
          if (p1Wrapped) {
            player1.style.transition = "opacity 0.15s ease-in-out";
            player1.style.opacity = "0.3";
            setTimeout(() => {
              player1.style.opacity = "1";
              setTimeout(() => {
                player1.style.transition = "none";
              }, 150);
            }, 50);
          }

          if (p2Wrapped && mode === 2) {
            player2.style.transition = "opacity 0.15s ease-in-out";
            player2.style.opacity = "0.3";
            setTimeout(() => {
              player2.style.opacity = "1";
              setTimeout(() => {
                player2.style.transition = "none";
              }, 150);
            }, 50);
          }

          // Update player positions
          player1.style.left = p1X + "px";
          player1.style.top = p1Y + "px";
          player2.style.left = p2X + "px";
          player2.style.top = p2Y + "px";

          // Update player appearance (facing direction)
          updatePlayerAppearance();

          // Check collisions
          checkCollisions();
        }
      }

      // Exit button
      document.getElementById("exitButton").addEventListener("click", () => {
        exitGame();
      });

      // Pause button
      document.getElementById("pauseButton").addEventListener("click", () => {
        const pauseBtn = document.getElementById("pauseButton");

        if (timer) {
          clearInterval(timer);
          timer = null;
          pauseBtn.innerHTML = "‚ñ∂ RESUME";
          pauseBtn.style.background = "rgba(40, 167, 69, 0.8)";
          showMessage("‚è∏ Game Paused");
        } else {
          timer = setInterval(gameTick, 1000);
          pauseBtn.innerHTML = "‚è∏ PAUSE";
          pauseBtn.style.background = "rgba(255, 193, 7, 0.8)";
          showMessage("‚ñ∂ Game Resumed");
        }
      });

      // Initialize when page loads
      document.addEventListener("DOMContentLoaded", init);

      // Also initialize immediately if DOM is already loaded
      if (document.readyState !== "loading") {
        init();
      }
    </script>
  </body>
</html>
