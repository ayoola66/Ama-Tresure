<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Ama Treasure Adventure - Complete Edition</title>
    <style>
      body {
        margin: 0;
        font-family: Arial, sans-serif;
        overflow: hidden;
        background: linear-gradient(to bottom right, #87ceeb, #f08080);
      }

      #game-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #1a1a1a;
        padding: 20px;
      }

      .game-stats {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1000;
        color: white;
        font-size: 16px;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        max-width: 55%;
        line-height: 1.4;
      }

      .game-stats > div {
        white-space: nowrap;
      }

      .game-header-buttons {
        position: fixed;
        top: 20px;
        right: 80px;
        display: flex;
        gap: 8px;
        z-index: 1000;
      }

      .game-header-button {
        padding: 8px 16px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;
        border: none;
        font-weight: bold;
        white-space: nowrap;
      }

      .game-header-button:hover {
        background: rgba(0, 0, 0, 0.9);
        transform: translateY(-2px);
      }

      .exit-button {
        background: rgba(220, 53, 69, 0.8);
      }

      .exit-button:hover {
        background: rgba(220, 53, 69, 0.9);
      }

      .pause-button {
        background: rgba(255, 193, 7, 0.8);
        color: black;
      }

      .pause-button:hover {
        background: rgba(255, 193, 7, 0.9);
      }

      /* Responsive adjustments for smaller screens */
      @media (max-width: 768px) {
        .game-stats {
          font-size: 14px;
          gap: 10px;
          max-width: 50%;
        }

        .game-header-button {
          padding: 6px 12px;
          font-size: 12px;
        }
      }

      @media (max-width: 480px) {
        .game-stats {
          font-size: 12px;
          gap: 8px;
          max-width: 45%;
        }

        .game-header-button {
          padding: 5px 10px;
          font-size: 11px;
        }

        .game-header-buttons {
          right: 65px;
        }
      }

      #startscreen {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        width: 90%;
        max-width: 600px;
        z-index: 1000;
        max-height: 90vh;
        overflow-y: auto;
      }

      #game {
        position: relative;
        width: 80vw;
        height: 80vh;
        border: 10px solid rgba(0, 0, 0, 0.8);
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        /* Dynamic background set by JavaScript based on Player 1's character choice */
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
      }

      .sprite {
        position: absolute;
        font-size: 50px;
        transition: all 0.1s ease-out;
        z-index: 2;
        user-select: none;
      }

      .obstacle {
        font-size: 60px;
        z-index: 1;
        animation: bounce 2s infinite ease-in-out;
      }

      .power-up {
        font-size: 40px;
        z-index: 2;
        animation: float 2s infinite ease-in-out;
        cursor: pointer;
      }

      .magnet-active {
        animation: pulse 1s infinite ease-in-out;
      }

      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-5px);
        }
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0px) scale(1);
        }
        50% {
          transform: translateY(-10px) scale(1.1);
        }
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(255, 165, 0, 0.7);
        }
        70% {
          transform: scale(1.1);
          box-shadow: 0 0 0 10px rgba(255, 165, 0, 0);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(255, 165, 0, 0);
        }
      }

      #gameover,
      #achievement {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        text-align: center;
        border-radius: 15px;
        z-index: 1000;
        display: none;
        max-width: 400px;
      }

      #achievement {
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 150, 0, 0.9);
        color: white;
        padding: 12px 20px;
        text-align: center;
        border-radius: 8px;
        z-index: 1001;
        display: none;
        font-size: 14px;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(0, 150, 0, 0.3);
        animation: slideInTop 0.3s ease-out;
        max-width: 350px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      @keyframes slideInTop {
        from {
          transform: translateX(-50%) translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateX(-50%) translateY(0);
          opacity: 1;
        }
      }

      @keyframes slideIn {
        from {
          transform: translate(-50%, -100%);
          opacity: 0;
        }
        to {
          transform: translate(-50%, -50%);
          opacity: 1;
        }
      }

      button {
        font-size: 18px;
        padding: 12px 24px;
        margin: 10px;
        border: none;
        border-radius: 8px;
        background: linear-gradient(45deg, #ff6b35, #f7931e);
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: bold;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
      }

      .game-title {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 32px;
        font-weight: bold;
        background: linear-gradient(
          to right,
          #462523 0%,
          #cb9b51 22%,
          #f6e27a 45%,
          #f6f2c0 50%,
          #f6e27a 55%,
          #cb9b51 78%,
          #462523 100%
        );
        background-size: 600px;
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
        -webkit-text-fill-color: transparent;
        animation: shine 3s infinite linear;
        z-index: 1000;
      }

      @keyframes shine {
        0% {
          background-position: 0;
        }
        60% {
          background-position: 600px;
        }
        100% {
          background-position: 600px;
        }
      }

      /* Leaderboard Styles */
      .leaderboard-container {
        background: rgba(0, 0, 0, 0.95);
        border-radius: 15px;
        padding: 15px;
        margin: 10px auto;
        max-width: 90vw;
        width: 500px;
        max-height: 70vh;
        overflow-y: auto;
        border: 2px solid #ffd700;
        box-shadow: 0 8px 32px rgba(255, 215, 0, 0.3);
        display: flex;
        flex-direction: column;
      }

      .leaderboard-title {
        text-align: center;
        color: #ffd700;
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 12px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        flex-shrink: 0;
      }

      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        overflow: hidden;
        flex-shrink: 1;
        min-height: 0;
      }

      .leaderboard-header {
        background: linear-gradient(135deg, #ffd700, #ffa500);
        color: #000;
        font-weight: bold;
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .leaderboard-header th {
        padding: 10px 5px;
        text-align: center;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .leaderboard-row {
        transition: all 0.3s ease;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .leaderboard-row:hover {
        background: rgba(255, 215, 0, 0.1);
      }

      .leaderboard-row td {
        padding: 8px 5px;
        text-align: center;
        color: #fff;
        font-size: 12px;
      }

      .leaderboard-position {
        font-weight: bold;
        color: #ffd700;
        font-size: 14px;
        width: 15%;
      }

      .leaderboard-name {
        font-weight: bold;
        max-width: 100px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        width: 35%;
      }

      .leaderboard-score {
        font-weight: bold;
        color: #00ff00;
        width: 25%;
      }

      .leaderboard-date {
        color: #ccc;
        font-size: 10px;
        width: 25%;
      }

      /* Special styling for top 3 positions */
      .leaderboard-row.position-1 .leaderboard-position {
        color: #ffd700;
        text-shadow: 0 0 10px #ffd700;
      }

      .leaderboard-row.position-2 .leaderboard-position {
        color: #c0c0c0;
        text-shadow: 0 0 10px #c0c0c0;
      }

      .leaderboard-row.position-3 .leaderboard-position {
        color: #cd7f32;
        text-shadow: 0 0 10px #cd7f32;
      }

      /* New score insertion animation */
      .leaderboard-row.new-entry {
        background: linear-gradient(90deg, transparent, #ffd700, transparent);
        animation: newScoreGlow 2s ease-in-out;
      }

      .leaderboard-row.inserting {
        transform: translateX(100%);
        opacity: 0;
        animation: slideInFromRight 0.8s ease-out forwards;
      }

      .leaderboard-row.moving-down {
        animation: moveDown 0.8s ease-out forwards;
      }

      @keyframes newScoreGlow {
        0%,
        100% {
          background: rgba(255, 215, 0, 0.1);
        }
        50% {
          background: rgba(255, 215, 0, 0.3);
        }
      }

      @keyframes slideInFromRight {
        0% {
          transform: translateX(100%);
          opacity: 0;
        }
        100% {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes moveDown {
        0% {
          transform: translateY(0);
        }
        100% {
          transform: translateY(50px);
        }
      }

      /* Leaderboard buttons */
      .leaderboard-buttons {
        text-align: center;
        margin-top: 12px;
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-shrink: 0;
        flex-wrap: wrap;
      }

      .leaderboard-button {
        padding: 10px 20px;
        background: linear-gradient(135deg, #4caf50, #45a049);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        white-space: nowrap;
      }

      .leaderboard-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      }

      .leaderboard-button.secondary {
        background: linear-gradient(135deg, #ff6b6b, #ff5252);
      }

      .leaderboard-button.secondary:hover {
        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
      }

      /* Responsive adjustments for leaderboard */
      @media (max-width: 600px) {
        .leaderboard-container {
          padding: 12px;
          max-height: 75vh;
        }

        .leaderboard-title {
          font-size: 18px;
          margin-bottom: 10px;
        }

        .leaderboard-header th {
          padding: 8px 3px;
          font-size: 10px;
        }

        .leaderboard-row td {
          padding: 6px 3px;
          font-size: 11px;
        }

        .leaderboard-position {
          font-size: 12px;
        }

        .leaderboard-date {
          font-size: 9px;
        }

        .leaderboard-button {
          padding: 8px 16px;
          font-size: 12px;
        }
      }

      @media (max-width: 400px) {
        .leaderboard-container {
          padding: 10px;
          max-height: 80vh;
        }

        .leaderboard-title {
          font-size: 16px;
        }

        .leaderboard-date {
          display: none; /* Hide date on very small screens */
        }

        .leaderboard-name {
          max-width: 80px;
        }
      }

      input {
        font-size: 16px;
        padding: 12px;
        margin: 10px;
        border-radius: 8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.1);
        color: white;
        width: 80%;
        max-width: 300px;
      }

      input:focus {
        outline: none;
        border-color: orange;
        background: rgba(255, 255, 255, 0.2);
      }

      input::placeholder {
        color: rgba(255, 255, 255, 0.6);
      }

      .mode-selection {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .mode-button {
        padding: 20px 30px;
        font-size: 18px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 220px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      .mode-button:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-3px);
      }

      .mode-button.selected {
        background: rgba(255, 165, 0, 0.4);
        border-color: orange;
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(255, 165, 0, 0.4);
      }

      .mode-button .icon {
        font-size: 36px;
      }

      .mode-button .description {
        font-size: 14px;
        opacity: 0.8;
      }

      .power-up-status {
        position: fixed;
        top: 100px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 8px;
        z-index: 1000;
        display: none;
      }

      .audio-toggle-button {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1001;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }

      .audio-toggle-button:hover {
        background: rgba(0, 0, 0, 0.9);
        transform: scale(1.1);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }

      .audio-toggle-button.active {
        background: rgba(255, 165, 0, 0.8);
        animation: pulse-audio 2s infinite;
      }

      @keyframes pulse-audio {
        0% {
          box-shadow: 0 4px 15px rgba(255, 165, 0, 0.3);
        }
        50% {
          box-shadow: 0 4px 25px rgba(255, 165, 0, 0.6);
        }
        100% {
          box-shadow: 0 4px 15px rgba(255, 165, 0, 0.3);
        }
      }

      /* Debug Panel Styles */
      .debug-toggle {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ff00;
        border: 2px solid #00ff00;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
        z-index: 1002;
        font-family: monospace;
      }

      .debug-toggle:hover {
        background: rgba(0, 0, 0, 0.9);
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      }

      .debug-panel {
        position: fixed;
        bottom: 60px;
        left: 20px;
        width: 450px;
        max-height: 400px;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #00ff00;
        border-radius: 8px;
        padding: 15px;
        z-index: 1001;
        display: none;
        overflow-y: auto;
        font-family: monospace;
        font-size: 11px;
        color: #00ff00;
      }

      .debug-panel.visible {
        display: block;
      }

      .debug-panel h3 {
        margin: 0 0 10px 0;
        color: #ffff00;
        font-size: 14px;
        text-align: center;
        border-bottom: 1px solid #00ff00;
        padding-bottom: 5px;
      }

      .debug-section {
        margin-bottom: 10px;
        padding: 8px;
        background: rgba(0, 255, 0, 0.05);
        border-radius: 4px;
      }

      .debug-section h4 {
        margin: 0 0 5px 0;
        color: #00ddff;
        font-size: 12px;
      }

      .debug-log {
        max-height: 150px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.5);
        padding: 8px;
        border-radius: 4px;
        margin-top: 5px;
      }

      .debug-log-entry {
        padding: 2px 0;
        border-bottom: 1px solid rgba(0, 255, 0, 0.2);
      }

      .debug-log-entry:last-child {
        border-bottom: none;
      }

      .log-time {
        color: #888;
        margin-right: 5px;
      }

      .log-treasure {
        color: #ffd700;
      }

      .log-level {
        color: #ff6b35;
      }

      .log-collision {
        color: #ff4444;
      }

      .log-power {
        color: #9b59b6;
      }

      .audio-controls {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(0, 0, 0, 0.9);
        padding: 20px;
        border-radius: 12px;
        color: white;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 15px;
        min-width: 220px;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transform: translateY(-10px);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .audio-controls.expanded {
        max-height: 300px;
        opacity: 1;
        transform: translateY(0);
      }

      .audio-controls h3 {
        margin: 0 0 10px 0;
        text-align: center;
        font-size: 18px;
        color: orange;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        padding-bottom: 10px;
      }

      .audio-controls button {
        padding: 8px;
        font-size: 14px;
        margin: 0;
      }

      .volume-control {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .volume-control input[type="range"] {
        flex: 1;
        width: auto;
        margin: 0;
        padding: 0;
      }

      #how-to-play {
        text-align: left;
        font-size: 16px;
        line-height: 1.6em;
        margin: 20px 0;
      }

      #how-to-play summary {
        cursor: pointer;
        font-size: 20px;
        margin-bottom: 15px;
        text-align: center;
        color: orange;
        font-weight: bold;
      }

      .character-selection {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 15px;
        margin: 20px auto;
        max-width: 400px;
        justify-items: center;
        align-items: center;
      }

      .character-option {
        padding: 15px 20px;
        font-size: 36px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        min-width: 100px;
        min-height: 100px;
        width: 100%;
        box-sizing: border-box;
      }

      .character-option:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
      }

      .character-option.selected {
        background: rgba(255, 165, 0, 0.8);
        border-color: orange;
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(255, 165, 0, 0.5);
      }

      /* Player Settings Sections */
      .player-section {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        padding: 25px;
        margin: 20px 0;
        border: 2px solid rgba(255, 255, 255, 0.2);
      }

      .player-section h3 {
        color: #ffd700;
        margin: 0 0 15px 0;
        text-align: center;
        font-size: 1.3em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }

      .player-section p {
        margin: 15px 0 10px 0;
        font-weight: bold;
        color: #fff;
        text-align: center;
      }

      .player-section input {
        width: 100%;
        max-width: 300px;
        margin: 0 auto;
        display: block;
      }

      .character-option .name {
        font-size: 12px;
        color: white;
        opacity: 0.8;
      }

      /* Loading Screen Styles */
      #loadingScreen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        gap: 30px;
      }

      #loadingScreen.hidden {
        display: none;
      }

      .loading-text {
        font-size: 24px;
        color: #ffd700;
        font-weight: bold;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        letter-spacing: 2px;
      }

      .loading-countdown-main {
        font-size: 120px;
        color: #ff6b6b;
        font-weight: bold;
        text-shadow: 0 0 30px rgba(255, 107, 107, 0.8),
          0 0 50px rgba(255, 107, 107, 0.5);
        letter-spacing: 2px;
        animation: countdownPulseMain 1s ease-in-out infinite;
        margin-bottom: 20px;
      }

      #countdownTimer {
        display: inline-block;
        min-width: 100px;
        text-align: center;
        line-height: 1;
      }

      @keyframes countdownPulseMain {
        0%,
        100% {
          transform: scale(1);
          text-shadow: 0 0 30px rgba(255, 107, 107, 0.8),
            0 0 50px rgba(255, 107, 107, 0.5);
        }
        50% {
          transform: scale(1.15);
          text-shadow: 0 0 40px rgba(255, 107, 107, 1),
            0 0 70px rgba(255, 107, 107, 0.7);
        }
      }

      .loading-dots {
        display: inline-block;
        font-size: 24px;
        color: #ffd700;
        margin-left: 5px;
      }

      .loading-dots::after {
        content: ".";
        animation: dots 1.5s steps(4, end) infinite;
      }

      @keyframes dots {
        0%,
        20% {
          content: ".";
        }
        40% {
          content: "..";
        }
        60% {
          content: "...";
        }
        80%,
        100% {
          content: "";
        }
      }

      .loading-characters {
        display: flex;
        gap: 15px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        max-width: 800px;
      }

      .loading-character {
        font-size: 80px;
        animation: pulsate 1.5s ease-in-out infinite;
        filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.4));
        transition: all 0.3s ease;
      }

      .loading-character:nth-child(1) {
        animation-delay: 0s;
      }

      .loading-character:nth-child(2) {
        animation-delay: 0.15s;
      }

      .loading-character:nth-child(3) {
        animation-delay: 0.3s;
      }

      .loading-character:nth-child(4) {
        animation-delay: 0.45s;
      }

      .loading-character:nth-child(5) {
        animation-delay: 0.6s;
      }

      .loading-character:nth-child(6) {
        animation-delay: 0.75s;
      }

      @keyframes pulsate {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.15);
          opacity: 0.8;
        }
      }

      .loading-hint {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        text-align: center;
        max-width: 400px;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <!-- Loading Screen -->
      <div id="loadingScreen">
        <div class="loading-countdown-main">
          <span id="countdownTimer">10</span>
        </div>

        <div>
          <div class="loading-text">
            Loading Game<span class="loading-dots"></span>
          </div>
        </div>
        <div class="loading-characters">
          <div class="loading-character">üßú‚Äç‚ôÄÔ∏è</div>
          <div class="loading-character">üèÉ‚Äç‚ôÇÔ∏è</div>
          <div class="loading-character">üêü</div>
          <div class="loading-character">üöó</div>
          <div class="loading-character">üêé</div>
          <div class="loading-character">üèÑ‚Äç‚ôÇÔ∏è</div>
        </div>
        <div class="loading-hint">Preloading all game assets...</div>
      </div>

      <div class="game-stats">
        <div>‚è≥ Time: <span id="timeDisplay">40</span></div>
        <div>üèÜ Level: <span id="levelDisplay">1</span></div>
        <div>‚≠ê High Score: <span id="highScoreDisplay">0</span></div>
        <div id="playerStats"></div>
      </div>

      <button
        class="audio-toggle-button"
        id="audioToggleBtn"
        title="Music Settings"
      >
        üéµ
      </button>

      <div class="audio-controls" id="audioControls">
        <h3>üéµ Audio Settings</h3>
        <button id="playMusicBtn">üéµ Play Music</button>
        <div class="volume-control">
          <span>üéµ</span>
          <input type="range" id="musicVolume" min="0" max="100" value="50" />
          <span id="musicVolumeValue">50%</span>
        </div>
        <div class="volume-control">
          <span>üîä</span>
          <input type="range" id="fxVolume" min="0" max="100" value="70" />
          <span id="fxVolumeValue">70%</span>
        </div>
        <button id="muteBtn">üîá Mute All</button>
      </div>

      <div class="power-up-status" id="powerUpStatus">
        <div>Active Power-up:</div>
        <div id="powerUpName">None</div>
        <div id="powerUpTime"></div>
      </div>

      <div class="game-header-buttons">
        <button id="exitButton" class="game-header-button exit-button">
          üè† EXIT GAME
        </button>
        <button id="pauseButton" class="game-header-button pause-button">
          ‚è∏ PAUSE
        </button>
      </div>

      <!-- Debug Panel -->
      <button class="debug-toggle" id="debugToggle">üêõ DEBUG</button>
      <div class="debug-panel" id="debugPanel">
        <h3>üêõ GAME ACTIVITY LOG</h3>

        <div class="debug-section">
          <h4>üìä Current Stats</h4>
          <div id="debugStats">Loading...</div>
        </div>

        <div class="debug-section">
          <h4>üìú Recent Activity (Last 15 events)</h4>
          <div class="debug-log" id="debugLog"></div>
        </div>
      </div>

      <div id="game">
        <div id="player1" class="sprite">üßú‚Äç‚ôÄÔ∏è</div>
        <div id="player2" class="sprite" style="display: none">üßë‚ÄçüöÄ</div>
        <div id="treasure" class="sprite">üí∞</div>
        <div id="gameover"></div>
        <div id="achievement"></div>

        <!-- Leaderboard Modal -->
        <div id="leaderboardModal" style="display: none">
          <div class="leaderboard-container">
            <div class="leaderboard-title">üèÜ TOP 10 LEADERBOARD üèÜ</div>
            <table class="leaderboard-table">
              <thead class="leaderboard-header">
                <tr>
                  <th>Rank</th>
                  <th>Player</th>
                  <th>Score</th>
                  <th>Date</th>
                </tr>
              </thead>
              <tbody id="leaderboardBody">
                <!-- Leaderboard entries will be inserted here -->
              </tbody>
            </table>
            <div class="leaderboard-buttons">
              <button class="leaderboard-button" onclick="startGame()">
                üîÑ Play Again
              </button>
              <button
                class="leaderboard-button secondary"
                onclick="backToMenu()"
              >
                üè† Main Menu
              </button>
            </div>
          </div>
        </div>
      </div>

      <div id="startscreen">
        <h2>üèùÔ∏è Ama Treasure Adventure üèùÔ∏è</h2>

        <div class="mode-selection">
          <button class="mode-button selected" data-mode="1">
            <span class="icon">ü§π‚Äç‚ôÇÔ∏è</span>
            <span class="label">Single Player</span>
            <span class="description">Challenge yourself in solo mode!</span>
          </button>
          <button class="mode-button" data-mode="2">
            <span class="icon">ü§∏‚Äç‚ôÇÔ∏èü§∏‚Äç‚ôÄÔ∏è</span>
            <span class="label">Two Players</span>
            <span class="description">Compete with a friend!</span>
          </button>
        </div>

        <!-- Player 1 Settings -->
        <div class="player-section">
          <h3>üéÆ Player 1 Setup</h3>
          <p>Enter Player 1 name:</p>
          <input
            id="player1Name"
            type="text"
            placeholder="Player 1 name"
            value="Player 1"
          />

          <p>Choose Player 1 character:</p>
          <div id="player1Characters" class="character-selection"></div>
        </div>

        <!-- Player 2 Settings -->
        <div id="player2Settings" class="player-section" style="display: none">
          <h3>üéÆ Player 2 Setup</h3>
          <p>Enter Player 2 name:</p>
          <input
            id="player2Name"
            type="text"
            placeholder="Player 2 name"
            value="Player 2"
          />

          <p>Choose Player 2 character:</p>
          <div id="player2Characters" class="character-selection"></div>
        </div>

        <details id="how-to-play">
          <summary>How to Play</summary>
          <p>
            <strong>üéØ Objective:</strong> Collect treasures and avoid obstacles
            before time runs out!
          </p>
          <p>
            <strong>üéÆ Controls:</strong><br />
            - <strong>Player 1:</strong> Arrow Keys (‚Üë‚Üì‚Üê‚Üí) - Character faces
            left/right<br />
            - <strong>Player 2:</strong> WASD Keys (W=Up, A=Left, S=Down,
            D=Right) - Character faces left/right<br />
            - <strong>ESC Key:</strong> Pause/Resume game anytime
          </p>
          <p>
            <strong>üé≠ Characters & Backgrounds:</strong><br />
            Choose from 6 unique characters: Mermaid, Runner, Fish, Car, Horse,
            or Surfer!<br />
            Each character has its own themed background environment<br />
            Characters face the direction they move (left/right only)
          </p>
          <p>
            <strong>üí∞ Treasures:</strong><br />
            - üí∞ Coins (1 point) - Common<br />
            - ‚ö™ Silver (3 points) - Uncommon<br />
            - üåü Gold (5 points) - Rare<br />
            - üíé Gems (10 points) - Very Rare
          </p>
          <p>
            <strong>‚ö° Power-ups (Level 3+):</strong><br />
            - üß≤ Magnet: Pulls treasures closer<br />
            - ‚ö° Speed: Move faster temporarily<br />
            - üõ°Ô∏è Shield: Temporary invincibility<br />
            - ‚ú® Points: Double points for duration
          </p>
          <p>
            <strong>üåä Dynamic Obstacles:</strong><br />
            - üêä Crocodiles face their movement direction and track players<br />
            - üî• Fire and ü•• Coconuts move randomly<br />
            - Obstacles respawn randomly when treasures are collected!
          </p>
          <p>
            <strong>üéµ Audio Controls:</strong><br />
            - Click the üéµ button (top-right) to open/close music settings<br />
            - Adjust music and sound effects volumes independently<br />
            - Play/pause music and mute all sounds
          </p>
          <p>
            <strong>üìä Level Progression:</strong><br />
            - Level 2 at 10 points, Level 3 at 30 pts, Level 4 at 60 pts<br />
            - Each level requires +10 more points than previous (+10, +20, +30,
            +40...)<br />
            - +10 seconds time bonus each level up<br />
            - Bonus life awarded at Level 6
          </p>
          <p>
            <strong>üéØ Obstacle Behavior:</strong><br />
            - Level 1: Static obstacles<br />
            - Level 2: Obstacles start bouncing<br />
            - Level 3+: Obstacles track players<br />
            - Level 5, 10, 15, 20, 25: Special horizontal crocodile appears!<br />
            - Level 26+: Horizontal crocodile EVERY level (maximum challenge!)
          </p>
        </details>

        <button onclick="startGame()">üöÄ Play Game</button>
      </div>

      <div class="game-title">AMA TREASURE ADVENTURE</div>
    </div>

    <!-- Debug Logger -->
    <script src="debug-logger.js"></script>

    <!-- Audio Elements -->
    <audio id="backgroundMusic" loop preload="auto">
      <source src="data/audio/background.mp3" type="audio/mpeg" />
      <source src="data/Game-Night-Groove-1.mp3" type="audio/mpeg" />
    </audio>
    <audio id="treasureSound" preload="auto">
      <source src="data/audio/treasure.mp3" type="audio/mpeg" />
    </audio>
    <audio id="powerupSound" preload="auto">
      <source src="data/audio/powerup.mp3" type="audio/mpeg" />
    </audio>
    <audio id="obstacleSound" preload="auto">
      <source src="data/audio/obstacle.mp3" type="audio/mpeg" />
    </audio>
    <audio id="achievementSound" preload="auto">
      <source src="data/audio/achievement.mp3" type="audio/mpeg" />
    </audio>
    <audio id="gameoverSound" preload="auto">
      <source src="data/audio/gameover.mp3" type="audio/mpeg" />
    </audio>
    <audio id="menuClickSound" preload="auto">
      <source src="data/audio/menu_click.mp3" type="audio/mpeg" />
    </audio>

    <script>
      // ====================================
      // LOADING SCREEN INITIALIZATION
      // ====================================
      const LOADING_DURATION = 10000; // 10 seconds
      let loadingComplete = false;

      // Initialize loading screen
      function initializeLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        const countdownTimer = document.getElementById("countdownTimer");
        let remainingTime = LOADING_DURATION / 1000; // 10 seconds
        
        console.log("üé¨ [LOADING SCREEN] Initializing loading screen...");
        
        // Set up loading screen close functionality
        const closeLoading = () => {
          if (loadingComplete || Date.now() - loadingStartTime >= LOADING_DURATION) {
            console.log("üé¨ [LOADING SCREEN] Closing loading screen...");
            loadingScreen.classList.add("hidden");
          }
        };
        
        // Close on click - INITIALIZE AUDIO HERE
        loadingScreen.addEventListener("click", () => {
          console.log("üñ±Ô∏è  [LOADING SCREEN] Click detected - initializing audio context");
          
          // Initialize audio context on first user interaction
          try {
            const audioElements = document.querySelectorAll("audio");
            audioElements.forEach((audio, index) => {
              console.log(`üîä [CLICK INIT] Attempting audio context init for: ${audio.id}`);
              const playPromise = audio.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    console.log(`‚úÖ [CLICK INIT] Audio context initialized for: ${audio.id}`);
                    audio.pause();
                    audio.currentTime = 0;
                  })
                  .catch((error) => {
                    console.log(`‚ö†Ô∏è  [CLICK INIT] Audio context init failed for ${audio.id}: ${error.message}`);
                  });
              }
            });
          } catch (e) {
            console.log(`‚ùå [CLICK INIT] Error initializing audio context:`, e.message);
          }
          
          closeLoading();
        });

        // Auto-close after 10 seconds
        loadingStartTime = Date.now();
        // Update countdown every second
        const countdownInterval = setInterval(() => {
          remainingTime--;
          if (countdownTimer) {
            countdownTimer.textContent = Math.max(0, remainingTime);
          }

          if (remainingTime <= 0) {
            clearInterval(countdownInterval);
          }
        }, 1000);

        const autoCloseTimer = setInterval(() => {
          if (Date.now() - loadingStartTime >= LOADING_DURATION) {
            clearInterval(autoCloseTimer);
            clearInterval(countdownInterval);
            loadingComplete = true;
            closeLoading();
          }
        }, 100);
      }

      let loadingStartTime = Date.now();

      // Preload all audio and images
      function preloadGameAssets() {
        console.log("üéÆ [PRELOAD START] Initializing game asset preload...");
        
        // Preload audio elements
        const audioElements = document.querySelectorAll("audio");
        console.log(`üéµ [AUDIO] Found ${audioElements.length} audio elements to preload`);
        
        audioElements.forEach((audio, index) => {
          audio.preload = "auto";
          audio.volume = 0.7; // Set default volume
          audio.load();
          console.log(`üéµ [AUDIO ${index}] Preloading: ${audio.id} (volume: 0.7)`);
          
          // Try to play silently to initialize audio context
          try {
            console.log(`üîä [AUDIO ${index}] Attempting silent play for: ${audio.id}`);
            const playPromise = audio.play();
            if (playPromise !== undefined) {
              playPromise.catch((error) => {
                console.log(`‚ö†Ô∏è  [AUDIO ${index}] Silent play blocked by browser: ${error.message}`);
              });
            }
            // Immediately pause to keep audio ready
            setTimeout(() => {
              audio.pause();
              audio.currentTime = 0;
              console.log(`‚úÖ [AUDIO ${index}] Paused and reset: ${audio.id}`);
            }, 10);
          } catch (e) {
            console.log(`‚ùå [AUDIO ${index}] Preload error for ${audio.id}:`, e.message);
          }
        });

        // Preload background images
        const backgroundImages = [
          "data/background/mermaid-background-1.png",
          "data/background/runMan-background-1.png",
          "data/background/fish-background-1.png",
          "data/background/redCar-background-1.png",
          "data/background/horse-background-1.png",
          "data/background/surfing-background-1.png",
        ];

        console.log(`üñºÔ∏è  [IMAGES] Preloading ${backgroundImages.length} background images`);
        backgroundImages.forEach((src, index) => {
          const img = new Image();
          img.src = src;
          console.log(`üñºÔ∏è  [IMAGE ${index}] Preloading: ${src}`);
        });

        console.log("‚úÖ [PRELOAD COMPLETE] Game assets preloading initiated...");
      }

      // Game Elements
      const player1 = document.getElementById("player1");
      const player2 = document.getElementById("player2");
      const treasure = document.getElementById("treasure");
      const gameover = document.getElementById("gameover");
      const startscreen = document.getElementById("startscreen");
      const achievement = document.getElementById("achievement");
      const gameContainer = document.getElementById("game");
      const powerUpStatus = document.getElementById("powerUpStatus");

      // Game State
      let obstacles = [];
      let powerUps = [];
      let mode = 1;
      let player1Name = "Player 1";
      let player2Name = "Player 2";
      let p1Score = 0,
        p2Score = 0;
      let p1Lives = 2,
        p2Lives = 2;
      let timeLeft = 40;
      let level = 1;
      let timer;
      let p1X = 100,
        p1Y = 100;
      let p2X = 200,
        p2Y = 200;
      const moveStep = 20;
      let highScore = localStorage.getItem("treasureHighScore") || 0;

      // Collision tracking to prevent multiple hits within short time
      let lastCollisionTime = {
        player1: { global: 0 },
        player2: { global: 0 },
      };
      const COLLISION_COOLDOWN = 1000; // 1 second between any hits

      // Debug Logging System (using external logger)
      const MAX_DEBUG_ENTRIES = 200; // Increased to track longer games up to level 20+

      function updateDebugPanel() {
        const logContainer = document.getElementById("debugLog");
        const statsContainer = document.getElementById("debugStats");

        if (!logContainer || !statsContainer) return;

        // Update stats
        const maxScore = Math.max(p1Score, mode === 2 ? p2Score : 0);
        const nextLevelPoints = getPointsForLevel(level + 1);
        const pointsToNextLevel = nextLevelPoints - maxScore;
        statsContainer.innerHTML = `
          <strong>P1:</strong> ${p1Score.toFixed(1)} pts, ${p1Lives} lives<br>
          ${
            mode === 2
              ? `<strong>P2:</strong> ${p2Score.toFixed(
                  1
                )} pts, ${p2Lives} lives<br>`
              : ""
          }
          <strong>Level:</strong> ${level} | <strong>Next Level:</strong> ${nextLevelPoints} pts (${pointsToNextLevel.toFixed(
          1
        )} away)<br>
          <strong>Time:</strong> ${timeLeft}s | <strong>Obstacles:</strong> ${
          obstacles.length
        }
        `;

        // Get recent logs from external logger
        const recentLogs = gameLogger.getRecentLogs(MAX_DEBUG_ENTRIES);

        // Update log display
        logContainer.innerHTML = recentLogs
          .map((entry) => {
            let className = "debug-log-entry";
            if (entry.type === "treasure") className += " log-treasure";
            else if (entry.type === "level") className += " log-level";
            else if (entry.type === "collision") className += " log-collision";
            else if (entry.type === "power") className += " log-power";

            return `<div class="${className}"><span class="log-time">[${entry.time}]</span> ${entry.message}</div>`;
          })
          .join("");
      }

      // Toggle debug panel
      function toggleDebugPanel() {
        const panel = document.getElementById("debugPanel");
        panel.classList.toggle("visible");
      }

      // Leaderboard System
      class LeaderboardManager {
        constructor() {
          this.storageKey = "treasureLeaderboard";
          this.maxEntries = 10;
        }

        // Get current leaderboard from localStorage
        getLeaderboard() {
          const stored = localStorage.getItem(this.storageKey);
          return stored ? JSON.parse(stored) : [];
        }

        // Save leaderboard to localStorage
        saveLeaderboard(leaderboard) {
          localStorage.setItem(this.storageKey, JSON.stringify(leaderboard));
        }

        // Add new score and return position (1-based, 0 if not in top 10)
        addScore(playerName, score) {
          const leaderboard = this.getLeaderboard();
          const timestamp = new Date().toISOString();

          const newEntry = {
            name: playerName,
            score: score,
            date: timestamp,
            id: Date.now() + Math.random(), // Unique ID for animations
          };

          // Find insertion position
          let insertPosition = leaderboard.length;
          for (let i = 0; i < leaderboard.length; i++) {
            if (score > leaderboard[i].score) {
              insertPosition = i;
              break;
            }
          }

          // Insert new entry
          leaderboard.splice(insertPosition, 0, newEntry);

          // Keep only top 10
          if (leaderboard.length > this.maxEntries) {
            leaderboard.splice(this.maxEntries);
          }

          this.saveLeaderboard(leaderboard);

          // Return position (1-based) or 0 if not in top 10
          const finalPosition = leaderboard.findIndex(
            (entry) => entry.id === newEntry.id
          );
          return finalPosition >= 0 ? finalPosition + 1 : 0;
        }

        // Get formatted leaderboard for display
        getFormattedLeaderboard() {
          return this.getLeaderboard().map((entry, index) => ({
            position: index + 1,
            name: entry.name,
            score: entry.score,
            date: new Date(entry.date).toLocaleDateString(),
            id: entry.id,
          }));
        }

        // Clear leaderboard (for testing)
        clearLeaderboard() {
          localStorage.removeItem(this.storageKey);
        }
      }

      // Initialize leaderboard manager
      const leaderboard = new LeaderboardManager();

      // Character selection and facing direction
      let selectedP1Character = "MERMAID";
      let selectedP2Character = "RUNNER";
      let p1FacingLeft = false;
      let p2FacingLeft = false;

      // Power-up system
      let activePowerUps = {
        player1: null,
        player2: null,
      };

      // Audio System using HTML5 Audio Elements
      let musicVolume = 0.5;
      let fxVolume = 0.7;
      let isMuted = false;
      let isPlaying = false;

      // Audio elements
      const backgroundMusic = document.getElementById("backgroundMusic");
      const treasureSound = document.getElementById("treasureSound");
      const powerupSound = document.getElementById("powerupSound");
      const obstacleSound = document.getElementById("obstacleSound");
      const achievementSound = document.getElementById("achievementSound");
      const gameoverSound = document.getElementById("gameoverSound");
      const menuClickSound = document.getElementById("menuClickSound");

      // Character options for players - Directional characters with clear left/right facing
      // Each character now has its own themed background image
      const characterOptions = {
        MERMAID: {
          emoji: "üßú‚Äç‚ôÄÔ∏è",
          name: "Mermaid",
          background: "data/background/mermaid-background-1.png",
        },
        RUNNER: {
          emoji: "üèÉ‚Äç‚ôÇÔ∏è",
          name: "Runner",
          background: "data/background/runMan-background-1.png",
        },
        FISH: {
          emoji: "üêü",
          name: "Fish",
          background: "data/background/fish-background-1.png",
        },
        CAR: {
          emoji: "üöó",
          name: "Car",
          background: "data/background/redCar-background-1.png",
        },
        HORSE: {
          emoji: "üêé",
          name: "Horse",
          background: "data/background/horse-background-1.png",
        },
        SURFER: {
          emoji: "üèÑ‚Äç‚ôÇÔ∏è",
          name: "Surfer",
          background: "data/background/surfing-background-1.png",
        },
      };

      const treasureTypes = {
        COIN: { emoji: "üí∞", points: 0.5, rarity: 0.6 },
        SILVER: { emoji: "‚ö™", points: 1, rarity: 0.25 },
        GOLD: { emoji: "üåü", points: 1.5, rarity: 0.1 },
        GEM: { emoji: "üíé", points: 2, rarity: 0.05 },
      };

      const powerUpTypes = {
        MAGNET: {
          emoji: "üß≤",
          duration: 6,
          effect: "Attract Treasures",
          minLevel: 3,
        },
        SPEED: { emoji: "‚ö°", duration: 5, effect: "2x Speed", minLevel: 3 },
        SHIELD: {
          emoji: "üõ°Ô∏è",
          duration: 8,
          effect: "Temporary Invincibility",
          minLevel: 4,
        },
        POINTS: { emoji: "‚ú®", duration: 7, effect: "2x Points", minLevel: 4 },
      };

      // Initialize audio system
      function initAudio() {
        // Get all audio elements
        const audioElements = [
          treasureSound,
          powerupSound,
          obstacleSound,
          achievementSound,
          gameoverSound,
          menuClickSound,
        ];

        // Force load all audio elements
        audioElements.forEach((audio) => {
          if (audio) {
            audio.load();
            audio.preload = "auto";
          }
        });

        // Set initial volumes
        updateAudioVolumes();

        // Enable user interaction for audio autoplay
        backgroundMusic.volume = musicVolume;

        // Initialize AudioContext for fallback sounds
        if (!audioContext) {
          try {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          } catch (e) {
            console.log("AudioContext initialization failed:", e);
          }
        }

        console.log("Audio system initialized with MP3 files");
      }

      // Update all audio volumes
      function updateAudioVolumes() {
        if (backgroundMusic) backgroundMusic.volume = isMuted ? 0 : musicVolume;
        if (treasureSound) treasureSound.volume = isMuted ? 0 : fxVolume;
        if (powerupSound) powerupSound.volume = isMuted ? 0 : fxVolume;
        if (obstacleSound) obstacleSound.volume = isMuted ? 0 : fxVolume;
        if (achievementSound) achievementSound.volume = isMuted ? 0 : fxVolume;
        if (gameoverSound) gameoverSound.volume = isMuted ? 0 : fxVolume;
        if (menuClickSound) menuClickSound.volume = isMuted ? 0 : fxVolume;
      }

      // Play specific sound effect
      function playAudio(audioElement) {
        if (!audioElement) {
          console.log("‚ùå [PLAY AUDIO] No audio element provided");
          return;
        }

        try {
          console.log(`üéµ [PLAY AUDIO] Playing: ${audioElement.id}`);
          console.log(`üéµ [PLAY AUDIO] Current state - readyState: ${audioElement.readyState}, paused: ${audioElement.paused}`);
          
          // Ensure audio is loaded
          if (audioElement.readyState < 2) {
            console.log(`üéµ [PLAY AUDIO] Audio not ready, loading: ${audioElement.id}`);
            audioElement.load();
          }

          // Set volume based on FX settings
          const fxVolume = document.getElementById("fxVolume")
            ? document.getElementById("fxVolume").value / 100
            : 0.7;

          // Apply mute only to volume, don't prevent playing
          audioElement.volume = isMuted ? 0 : fxVolume;
          console.log(`üéµ [PLAY AUDIO] Volume set to ${audioElement.volume} (fxVolume: ${fxVolume}, isMuted: ${isMuted})`);
          
          audioElement.currentTime = 0; // Reset to start

          // Force play the audio
          const playPromise = audioElement.play();
          console.log(`üéµ [PLAY AUDIO] Play promise: ${playPromise ? "exists" : "undefined"}`);

          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                console.log(`‚úÖ [PLAY AUDIO] Successfully played: ${audioElement.id}`);
              })
              .catch((e) => {
                console.log(`‚ùå [PLAY AUDIO] Failed to play ${audioElement.id}: ${e.message}`);
                // Fallback to procedural sound
                fallbackProceduralSound(audioElement.id || "default");
              });
          }
        } catch (e) {
          console.log(`‚ùå [PLAY AUDIO] Exception for ${audioElement.id}:`, e.message);
          fallbackProceduralSound(audioElement.id || "default");
        }
      }

      // Fallback procedural sound generation
      function fallbackProceduralSound(soundType) {
        if (isMuted) return;

        // Initialize AudioContext if needed
        if (!audioContext) {
          try {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          } catch (e) {
            console.log("AudioContext not available");
            return;
          }
        }

        try {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          // Get FX volume for procedural sounds
          const fxVolume = document.getElementById("fxVolume")
            ? document.getElementById("fxVolume").value / 100
            : 0.7;

          // Different tones for different sound types
          switch (soundType) {
            case "treasureSound":
              oscillator.frequency.value = 800;
              gainNode.gain.setValueAtTime(
                0.1 * fxVolume,
                audioContext.currentTime
              );
              gainNode.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + 0.3
              );
              break;
            case "powerupSound":
              oscillator.frequency.value = 600;
              gainNode.gain.setValueAtTime(
                0.15 * fxVolume,
                audioContext.currentTime
              );
              gainNode.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + 0.5
              );
              break;
            case "obstacleSound":
              oscillator.frequency.value = 200;
              gainNode.gain.setValueAtTime(
                0.1 * fxVolume,
                audioContext.currentTime
              );
              gainNode.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + 0.2
              );
              break;
            case "achievementSound":
              oscillator.frequency.value = 1000;
              gainNode.gain.setValueAtTime(
                0.1 * fxVolume,
                audioContext.currentTime
              );
              gainNode.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + 0.8
              );
              break;
            case "gameoverSound":
              oscillator.frequency.value = 150;
              gainNode.gain.setValueAtTime(
                0.15 * fxVolume,
                audioContext.currentTime
              );
              gainNode.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + 1.0
              );
              break;
            default:
              oscillator.frequency.value = 440;
              gainNode.gain.setValueAtTime(
                0.1 * fxVolume,
                audioContext.currentTime
              );
              gainNode.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + 0.2
              );
          }

          oscillator.start();
          oscillator.stop(audioContext.currentTime + 1);
          console.log(`Procedural sound played: ${soundType}`);
        } catch (e) {
          console.log("Fallback sound failed:", e);
        }
      }

      // Background music controls
      function startBackgroundMusic() {
        if (!backgroundMusic || isMuted) return;

        try {
          backgroundMusic.currentTime = 0;
          backgroundMusic
            .play()
            .then(() => {
              isPlaying = true;
              console.log("Background music started");
            })
            .catch((e) => {
              console.log("Background music failed to start:", e.message);
              // Fall back to procedural music if MP3 fails
              fallbackToProceduralMusic();
            });
        } catch (e) {
          console.log("Background music error:", e);
          fallbackToProceduralMusic();
        }
      }

      function stopBackgroundMusic() {
        if (backgroundMusic) {
          backgroundMusic.pause();
          backgroundMusic.currentTime = 0;
        }
        isPlaying = false;

        // Also stop procedural music if it's running
        if (musicInterval) {
          clearInterval(musicInterval);
          musicInterval = null;
        }
      }

      // Fallback procedural music system
      let audioContext = null;
      let musicInterval = null;

      function fallbackToProceduralMusic() {
        console.log("Falling back to procedural music");

        if (!audioContext) {
          try {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          } catch (e) {
            console.log("Web Audio API not supported");
            return;
          }
        }

        if (musicInterval || isMuted) return;

        const notes = [261.63, 293.66, 329.63, 349.23, 392.0, 440.0, 493.88];
        let noteIndex = 0;

        musicInterval = setInterval(() => {
          if (!isMuted && isPlaying) {
            try {
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();

              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);

              oscillator.frequency.setValueAtTime(
                notes[noteIndex],
                audioContext.currentTime
              );
              oscillator.type = "triangle";

              gainNode.gain.setValueAtTime(
                musicVolume * 0.1,
                audioContext.currentTime
              );
              gainNode.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + 0.3
              );

              oscillator.start(audioContext.currentTime);
              oscillator.stop(audioContext.currentTime + 0.3);

              noteIndex = (noteIndex + 1) % notes.length;
            } catch (e) {
              console.log("Procedural music error:", e);
            }
          }
        }, 800);
      }

      // Audio controls
      document.getElementById("playMusicBtn").addEventListener("click", () => {
        initAudio();

        const btn = document.getElementById("playMusicBtn");

        if (!isPlaying) {
          startBackgroundMusic();
          btn.textContent = "‚è∏ Pause Music";
        } else {
          stopBackgroundMusic();
          btn.textContent = "üéµ Play Music";
        }
      });

      document.getElementById("musicVolume").addEventListener("input", (e) => {
        musicVolume = e.target.value / 100;
        document.getElementById("musicVolumeValue").textContent =
          e.target.value + "%";
        updateAudioVolumes();
      });

      document.getElementById("fxVolume").addEventListener("input", (e) => {
        fxVolume = e.target.value / 100;
        document.getElementById("fxVolumeValue").textContent =
          e.target.value + "%";
        updateAudioVolumes();
      });

      document.getElementById("muteBtn").addEventListener("click", () => {
        isMuted = !isMuted;
        const btn = document.getElementById("muteBtn");
        btn.textContent = isMuted ? "üîä Unmute" : "üîá Mute All";

        updateAudioVolumes();

        if (isMuted) {
          stopBackgroundMusic();
        } else if (isPlaying) {
          startBackgroundMusic();
        }
      });

      // Audio panel toggle functionality
      let audioControlsExpanded = false;

      document
        .getElementById("audioToggleBtn")
        .addEventListener("click", () => {
          const audioControls = document.getElementById("audioControls");
          const toggleBtn = document.getElementById("audioToggleBtn");

          audioControlsExpanded = !audioControlsExpanded;

          if (audioControlsExpanded) {
            audioControls.classList.add("expanded");
            toggleBtn.classList.add("active");
            toggleBtn.innerHTML = "üé∂";
          } else {
            audioControls.classList.remove("expanded");
            toggleBtn.classList.remove("active");
            toggleBtn.innerHTML = "üéµ";
          }

          playAudio(menuClickSound);
        });

      // Close audio controls when clicking outside
      document.addEventListener("click", (e) => {
        const audioControls = document.getElementById("audioControls");
        const toggleBtn = document.getElementById("audioToggleBtn");

        if (
          audioControlsExpanded &&
          !audioControls.contains(e.target) &&
          !toggleBtn.contains(e.target)
        ) {
          audioControls.classList.remove("expanded");
          toggleBtn.classList.remove("active");
          toggleBtn.innerHTML = "üéµ";
          audioControlsExpanded = false;
        }
      });

      // Initialize character selection
      function initializeCharacterSelection() {
        const p1Container = document.getElementById("player1Characters");
        const p2Container = document.getElementById("player2Characters");

        // Clear existing characters
        p1Container.innerHTML = "";
        p2Container.innerHTML = "";

        // Create character options for both players
        Object.entries(characterOptions).forEach(([key, character]) => {
          // Player 1 character option
          const p1Option = document.createElement("div");
          p1Option.className = "character-option";
          if (key === selectedP1Character) p1Option.classList.add("selected");
          p1Option.innerHTML = `
             <div class="emoji">${character.emoji}</div>
             <div class="name">${character.name}</div>
           `;
          p1Option.addEventListener("click", () => {
            selectedP1Character = key;
            updateCharacterSelection("player1");
            playAudio(menuClickSound);
            // Immediately update background when character is selected
            updateBackgroundPreview(key);
          });
          p1Container.appendChild(p1Option);

          // Player 2 character option
          const p2Option = document.createElement("div");
          p2Option.className = "character-option";
          if (key === selectedP2Character) p2Option.classList.add("selected");
          p2Option.innerHTML = `
             <div class="emoji">${character.emoji}</div>
             <div class="name">${character.name}</div>
           `;
          p2Option.addEventListener("click", () => {
            selectedP2Character = key;
            updateCharacterSelection("player2");
            playAudio(menuClickSound);
          });
          p2Container.appendChild(p2Option);
        });
      }

      function updateCharacterSelection(player) {
        const container = document.getElementById(
          player === "player1" ? "player1Characters" : "player2Characters"
        );
        const selectedChar =
          player === "player1" ? selectedP1Character : selectedP2Character;

        container
          .querySelectorAll(".character-option")
          .forEach((option, index) => {
            const characterKey = Object.keys(characterOptions)[index];
            if (characterKey === selectedChar) {
              option.classList.add("selected");
            } else {
              option.classList.remove("selected");
            }
          });

        // Update background preview when Player 1 selects a character
        if (player === "player1") {
          updateBackgroundPreview(selectedChar);
        }
      }

      // Update background preview based on Player 1's character selection
      function updateBackgroundPreview(characterKey) {
        const gameContainer = document.getElementById("game");
        const selectedCharacter = characterOptions[characterKey];

        if (selectedCharacter && selectedCharacter.background) {
          gameContainer.style.backgroundImage = `url("${selectedCharacter.background}")`;
          console.log(`Background changed to: ${selectedCharacter.name} theme`);
        }
      }

      // Update player appearance based on selection and facing direction
      function updatePlayerAppearance() {
        const p1Char = characterOptions[selectedP1Character];
        const p2Char = characterOptions[selectedP2Character];

        // Simple facing logic - just use the character emoji
        // Most emojis naturally face LEFT, so we flip them when facing RIGHT
        player1.innerText = p1Char.emoji;
        player2.innerText = p2Char.emoji;

        // Add visual indicator for facing direction with CSS transform
        // INVERTED: Most emojis face left by default, so flip when facing RIGHT (facingLeft = false)
        player1.style.transform = p1FacingLeft ? "scaleX(1)" : "scaleX(-1)";
        player2.style.transform = p2FacingLeft ? "scaleX(1)" : "scaleX(-1)";
      }

      // Initialize game
      function init() {
        console.log("Initializing game...");

        // Initialize loading screen and preload all assets
        preloadGameAssets();
        initializeLoadingScreen();

        // Show start screen
        startscreen.style.display = "block";
        player1.style.display = "none";
        player2.style.display = "none";
        treasure.style.display = "none";
        document.querySelector(".game-header-buttons").style.display = "none";
        powerUpStatus.style.display = "none";

        // Update high score display
        document.getElementById("highScoreDisplay").textContent = highScore;

        // Initialize character selection
        initializeCharacterSelection();

        // Set initial background based on default Player 1 character (Mermaid)
        updateBackgroundPreview(selectedP1Character);

        // Mode selection
        document.querySelectorAll(".mode-button").forEach((button) => {
          button.addEventListener("click", () => {
            document
              .querySelectorAll(".mode-button")
              .forEach((b) => b.classList.remove("selected"));
            button.classList.add("selected");
            mode = parseInt(button.dataset.mode);
            playAudio(menuClickSound); // Click sound

            const player2Settings = document.getElementById("player2Settings");
            if (mode === 2) {
              player2Settings.style.display = "block";
            } else {
              player2Settings.style.display = "none";
            }
          });
        });

        console.log("Game initialized");
      }

      function randomPosition() {
        const game = document.getElementById("game");
        const x = Math.random() * (game.clientWidth - 60);
        const y = Math.random() * (game.clientHeight - 60);
        return { x, y };
      }

      // Check if a position overlaps with existing elements
      function isPositionSafe(x, y, elementWidth = 60, excludeElement = null) {
        const newRect = {
          left: x,
          top: y,
          right: x + elementWidth,
          bottom: y + elementWidth,
        };

        // Check against players
        const p1Rect = player1.getBoundingClientRect();
        const p2Rect = player2.getBoundingClientRect();

        if (
          isRectOverlapping(newRect, {
            left: parseFloat(player1.style.left),
            top: parseFloat(player1.style.top),
            right: parseFloat(player1.style.left) + 60,
            bottom: parseFloat(player1.style.top) + 60,
          })
        )
          return false;

        if (
          mode === 2 &&
          isRectOverlapping(newRect, {
            left: parseFloat(player2.style.left),
            top: parseFloat(player2.style.top),
            right: parseFloat(player2.style.left) + 60,
            bottom: parseFloat(player2.style.top) + 60,
          })
        )
          return false;

        // Check against obstacles
        for (let obs of obstacles) {
          if (obs === excludeElement) continue;

          const obsRect = {
            left: parseFloat(obs.style.left),
            top: parseFloat(obs.style.top),
            right: parseFloat(obs.style.left) + 60,
            bottom: parseFloat(obs.style.top) + 60,
          };

          if (isRectOverlapping(newRect, obsRect)) return false;
        }

        // Check against treasure (if not excluding it)
        if (excludeElement !== treasure && treasure.style.display !== "none") {
          const treasureRect = {
            left: parseFloat(treasure.style.left),
            top: parseFloat(treasure.style.top),
            right: parseFloat(treasure.style.left) + 60,
            bottom: parseFloat(treasure.style.top) + 60,
          };

          if (isRectOverlapping(newRect, treasureRect)) return false;
        }

        // Check against power-ups
        for (let powerUp of powerUps) {
          if (powerUp === excludeElement) continue;

          const powerUpRect = {
            left: parseFloat(powerUp.style.left),
            top: parseFloat(powerUp.style.top),
            right: parseFloat(powerUp.style.left) + 60,
            bottom: parseFloat(powerUp.style.top) + 60,
          };

          if (isRectOverlapping(newRect, powerUpRect)) return false;
        }

        return true;
      }

      // Check if two rectangles overlap
      function isRectOverlapping(rect1, rect2) {
        return !(
          rect1.right < rect2.left ||
          rect2.right < rect1.left ||
          rect1.bottom < rect2.top ||
          rect2.bottom < rect1.top
        );
      }

      // Get a safe random position that doesn't overlap with other elements
      function getSafeRandomPosition(excludeElement = null, maxAttempts = 50) {
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
          const pos = randomPosition();
          if (isPositionSafe(pos.x, pos.y, 60, excludeElement)) {
            return pos;
          }
        }

        // If we can't find a safe position after max attempts, return a random one
        // This prevents infinite loops but is rare
        console.warn("Could not find safe position, using random position");
        return randomPosition();
      }

      function placeTreasure() {
        // Select random treasure type based on rarity
        const rand = Math.random();
        let selectedType = treasureTypes.COIN;
        let cumulative = 0;

        for (const type of Object.values(treasureTypes)) {
          cumulative += type.rarity;
          if (rand <= cumulative) {
            selectedType = type;
            break;
          }
        }

        treasure.innerText = selectedType.emoji;
        treasure.dataset.points = selectedType.points;
        treasure.dataset.type = Object.keys(treasureTypes).find(
          (key) => treasureTypes[key] === selectedType
        );

        // Use safe positioning to avoid overlaps
        const pos = getSafeRandomPosition(treasure);
        treasure.style.left = pos.x + "px";
        treasure.style.top = pos.y + "px";

        // Check and resolve treasure-obstacle collisions
        resolveTreasureObstacleCollisions();
      }

      // Check for treasure-obstacle collisions and relocate obstacles if needed
      function resolveTreasureObstacleCollisions() {
        const treasureRect = {
          left: parseFloat(treasure.style.left),
          top: parseFloat(treasure.style.top),
          right: parseFloat(treasure.style.left) + 60,
          bottom: parseFloat(treasure.style.top) + 60,
        };

        obstacles.forEach((obstacle) => {
          const obstacleRect = {
            left: parseFloat(obstacle.style.left),
            top: parseFloat(obstacle.style.top),
            right: parseFloat(obstacle.style.left) + 60,
            bottom: parseFloat(obstacle.style.top) + 60,
          };

          // Check if treasure and obstacle are too close (within 80px)
          const distance = Math.sqrt(
            Math.pow(treasureRect.left - obstacleRect.left, 2) +
              Math.pow(treasureRect.top - obstacleRect.top, 2)
          );

          if (distance < 80) {
            console.log(
              "üö´ Treasure-obstacle collision detected, relocating obstacle"
            );

            // Find a new safe position for the obstacle
            const newPos = getSafeRandomPosition(obstacle);
            obstacle.style.left = newPos.x + "px";
            obstacle.style.top = newPos.y + "px";

            console.log("‚úÖ Obstacle relocated to avoid treasure collision");
          }
        });
      }

      function createPowerUp() {
        if (level < 3) return; // Power-ups only appear from level 3+
        if (powerUps.length >= 2) return; // Max 2 power-ups at once
        if (Math.random() > 0.3) return; // 30% chance

        const availablePowerUps = Object.entries(powerUpTypes).filter(
          ([_, type]) => level >= type.minLevel
        );
        if (availablePowerUps.length === 0) return;

        const [powerUpName, powerUpType] =
          availablePowerUps[
            Math.floor(Math.random() * availablePowerUps.length)
          ];

        const powerUp = document.createElement("div");
        powerUp.className = "power-up sprite";
        powerUp.innerText = powerUpType.emoji;
        powerUp.dataset.type = powerUpName;

        const pos = getSafeRandomPosition(); // Use safe positioning
        powerUp.style.left = pos.x + "px";
        powerUp.style.top = pos.y + "px";

        gameContainer.appendChild(powerUp);
        powerUps.push(powerUp);

        // Remove power-up after 10 seconds
        setTimeout(() => {
          if (powerUps.includes(powerUp)) {
            powerUp.remove();
            powerUps = powerUps.filter((p) => p !== powerUp);
          }
        }, 10000);
      }

      function createObstacles() {
        // Clear existing obstacles
        obstacles.forEach((obs) => obs.remove());
        obstacles = [];

        const obstacleTypes = [
          { emoji: "üêä", type: "crocodile", faceable: true },
          { emoji: "üî•", type: "fire", faceable: false },
          { emoji: "ü••", type: "coconut", faceable: false },
        ];
        let obstacleCount = 2;

        if (level >= 13) obstacleCount = 8;
        else if (level >= 9) obstacleCount = 6;
        else if (level >= 6) obstacleCount = 5;
        else if (level >= 4) obstacleCount = 4;
        else if (level >= 3) obstacleCount = 3;

        for (let i = 0; i < obstacleCount; i++) {
          const obs = document.createElement("div");
          obs.className = "obstacle sprite";

          const selectedObstacle =
            obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
          obs.innerText = selectedObstacle.emoji;
          obs.dataset.type = selectedObstacle.type;
          obs.dataset.faceable = selectedObstacle.faceable;

          const pos = getSafeRandomPosition(); // Use safe positioning to avoid overlaps
          obs.style.left = pos.x + "px";
          obs.style.top = pos.y + "px";

          // Set movement direction and speed
          const dx = (Math.random() - 0.5) * (2 + level * 0.5);
          const dy = (Math.random() - 0.5) * (2 + level * 0.5);
          obs.dataset.dx = dx;
          obs.dataset.dy = dy;

          // Set initial facing direction for crocodiles
          if (selectedObstacle.faceable) {
            obs.dataset.facingLeft = dx < 0 ? "true" : "false";
            obs.style.transform = dx < 0 ? "scaleX(-1)" : "scaleX(1)";
          }

          gameContainer.appendChild(obs);
          obstacles.push(obs);
        }
      }

      // Random obstacle respawn when treasure is collected
      function randomObstacleRespawn() {
        if (obstacles.length === 0) return;

        // Randomly remove 1-2 obstacles
        const removeCount = Math.min(
          Math.floor(Math.random() * 2) + 1,
          obstacles.length
        );

        for (let i = 0; i < removeCount; i++) {
          const randomIndex = Math.floor(Math.random() * obstacles.length);
          const obstacleToRemove = obstacles[randomIndex];
          obstacleToRemove.remove();
          obstacles.splice(randomIndex, 1);
        }

        // Add new obstacles at random positions
        const obstacleTypes = [
          { emoji: "üêä", type: "crocodile", faceable: true },
          { emoji: "üî•", type: "fire", faceable: false },
          { emoji: "ü••", type: "coconut", faceable: false },
        ];

        for (let i = 0; i < removeCount; i++) {
          const obs = document.createElement("div");
          obs.className = "obstacle sprite";

          const selectedObstacle =
            obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
          obs.innerText = selectedObstacle.emoji;
          obs.dataset.type = selectedObstacle.type;
          obs.dataset.faceable = selectedObstacle.faceable;

          const pos = randomPosition();
          obs.style.left = pos.x + "px";
          obs.style.top = pos.y + "px";

          // Set movement direction and speed
          const dx = (Math.random() - 0.5) * (2 + level * 0.5);
          const dy = (Math.random() - 0.5) * (2 + level * 0.5);
          obs.dataset.dx = dx;
          obs.dataset.dy = dy;

          // Set initial facing direction for crocodiles
          if (selectedObstacle.faceable) {
            obs.dataset.facingLeft = dx < 0 ? "true" : "false";
            obs.style.transform = dx < 0 ? "scaleX(-1)" : "scaleX(1)";
          }

          gameContainer.appendChild(obs);
          obstacles.push(obs);
        }
      }

      function moveObstacles() {
        // Obstacles start oscillating from Level 2, tracking from Level 3
        if (level < 2) return;

        obstacles.forEach((obs) => {
          // Skip special horizontal-moving crocodiles
          if (obs.dataset.special === "horizontal") return;
          let currentLeft = parseFloat(obs.style.left);
          let currentTop = parseFloat(obs.style.top);
          let dx = parseFloat(obs.dataset.dx);
          let dy = parseFloat(obs.dataset.dy);
          let oldDx = dx; // Store original dx to check for direction change

          // Level 2: Simple oscillating/bouncing movement
          if (level >= 2 && level < 3) {
            // Just bounce around randomly
            if (Math.random() < 0.03) {
              // 3% chance to change direction
              dx = (Math.random() - 0.5) * 3;
              dy = (Math.random() - 0.5) * 3;
              obs.dataset.dx = dx;
              obs.dataset.dy = dy;
            }
          }

          // Level 3+: Player-tracking movement towards nearest character
          if (level >= 3) {
            // Find nearest player
            let nearestPlayer = player1;
            let nearestDistance = Infinity;

            const obsRect = obs.getBoundingClientRect();

            // Check distance to player 1
            const p1Rect = player1.getBoundingClientRect();
            const p1Distance = Math.sqrt(
              Math.pow(p1Rect.left - obsRect.left, 2) +
                Math.pow(p1Rect.top - obsRect.top, 2)
            );

            nearestDistance = p1Distance;

            // Check distance to player 2 if in two-player mode
            if (mode === 2) {
              const p2Rect = player2.getBoundingClientRect();
              const p2Distance = Math.sqrt(
                Math.pow(p2Rect.left - obsRect.left, 2) +
                  Math.pow(p2Rect.top - obsRect.top, 2)
              );

              if (p2Distance < nearestDistance) {
                nearestPlayer = player2;
                nearestDistance = p2Distance;
              }
            }

            // Move towards nearest player with increasing intensity based on level
            const playerRect = nearestPlayer.getBoundingClientRect();
            const trackingRange = 300; // Always track within this range
            // Level 3: Slower tracking, Level 4+: Faster tracking
            const baseTracking = level === 3 ? 0.2 : 0.3;
            const trackingStrength = baseTracking + (level - 3) * 0.05; // Increase with level starting from level 3

            if (nearestDistance < trackingRange) {
              const directionX = playerRect.left > obsRect.left ? 1 : -1;
              const directionY = playerRect.top > obsRect.top ? 1 : -1;

              dx += directionX * trackingStrength;
              dy += directionY * trackingStrength;

              // Cap the speed to prevent obstacles from becoming too fast
              const maxSpeed = 3 + (level - 3) * 0.15; // Adjusted for level 3 start
              dx = Math.max(-maxSpeed, Math.min(maxSpeed, dx));
              dy = Math.max(-maxSpeed, Math.min(maxSpeed, dy));

              obs.dataset.dx = dx;
              obs.dataset.dy = dy;
            }
          }

          // Move obstacle
          currentLeft += dx;
          currentTop += dy;

          // Bounce off walls and update facing direction
          if (
            currentLeft <= 0 ||
            currentLeft >= gameContainer.clientWidth - 60
          ) {
            dx = -dx;
            obs.dataset.dx = dx;
          }
          if (
            currentTop <= 0 ||
            currentTop >= gameContainer.clientHeight - 60
          ) {
            dy = -dy;
            obs.dataset.dy = dy;
          }

          // Update facing direction for faceable obstacles (like crocodiles)
          if (obs.dataset.faceable === "true") {
            const newFacingLeft = dx < 0;
            const currentFacingLeft = obs.dataset.facingLeft === "true";

            if (newFacingLeft !== currentFacingLeft) {
              obs.dataset.facingLeft = newFacingLeft ? "true" : "false";
              obs.style.transform = newFacingLeft ? "scaleX(-1)" : "scaleX(1)";
            }
          }

          // Keep in bounds
          currentLeft = Math.max(
            0,
            Math.min(gameContainer.clientWidth - 60, currentLeft)
          );
          currentTop = Math.max(
            0,
            Math.min(gameContainer.clientHeight - 60, currentTop)
          );

          obs.style.left = currentLeft + "px";
          obs.style.top = currentTop + "px";
        });

        // Handle special horizontal-moving crocodiles
        moveSpecialCrocodiles();

        // Remove special crocodiles if not at milestone level
        if (!shouldSpawnSpecialCrocodile(level)) {
          removeSpecialCrocodiles();
        }
      }

      // Check if special crocodile should spawn at this level
      function shouldSpawnSpecialCrocodile(currentLevel) {
        // Up to level 25: appears at 5, 10, 15, 20, 25 (every 5th)
        if (currentLevel <= 25) {
          return currentLevel % 5 === 0 && currentLevel >= 5;
        }
        // After level 25: appears every single level (26, 27, 28, 29, 30...)
        return currentLevel > 25;
      }

      // Special horizontal-moving crocodile that appears at milestone levels
      function moveSpecialCrocodiles() {
        const specialCrocs = obstacles.filter(
          (obs) => obs.dataset.special === "horizontal"
        );

        specialCrocs.forEach((croc) => {
          let currentLeft = parseFloat(croc.style.left);
          const speed = parseFloat(croc.dataset.speed) || 3;
          const direction = parseFloat(croc.dataset.direction) || 1;

          // Move horizontally
          currentLeft += speed * direction;

          // Remove if off screen and recreate on opposite side
          if (
            (direction > 0 && currentLeft > gameContainer.clientWidth) ||
            (direction < 0 && currentLeft < -60)
          ) {
            // Remove this croc
            croc.remove();
            const index = obstacles.indexOf(croc);
            if (index > -1) obstacles.splice(index, 1);

            // Create new one on opposite side if still at appropriate level
            if (shouldSpawnSpecialCrocodile(level)) {
              createSpecialCrocodile();
            }
          } else {
            croc.style.left = currentLeft + "px";
          }
        });
      }

      // Remove special crocodiles when level changes to non-milestone level
      function removeSpecialCrocodiles() {
        const specialCrocs = obstacles.filter(
          (obs) => obs.dataset.special === "horizontal"
        );

        specialCrocs.forEach((croc) => {
          croc.remove();
          const index = obstacles.indexOf(croc);
          if (index > -1) obstacles.splice(index, 1);
        });

        if (specialCrocs.length > 0) {
          gameLogger.addLog(
            `üêä Special horizontal crocodile removed (not a milestone level)`,
            "info"
          );
        }
      }

      // Create special horizontal-moving crocodile
      function createSpecialCrocodile() {
        const game = document.getElementById("game");
        const croc = document.createElement("div");
        croc.className = "obstacle sprite";
        croc.innerText = "üêä";
        croc.dataset.type = "crocodile";
        croc.dataset.faceable = "true";
        croc.dataset.special = "horizontal";

        // Random vertical position (different sections of screen)
        const sections = 3;
        const section = Math.floor(Math.random() * sections);
        const yPos =
          (game.clientHeight / sections) * section +
          Math.random() * (game.clientHeight / sections - 60);

        // Random direction: left-to-right or right-to-left
        const direction = Math.random() > 0.5 ? 1 : -1;
        const speed = 2 + Math.random(); // Random speed between 2-3

        // Start position based on direction
        const xPos = direction > 0 ? -60 : game.clientWidth;

        croc.style.left = xPos + "px";
        croc.style.top = yPos + "px";
        croc.dataset.speed = speed;
        croc.dataset.direction = direction;

        // Set facing direction
        croc.dataset.facingLeft = direction < 0 ? "true" : "false";
        croc.style.transform = direction < 0 ? "scaleX(-1)" : "scaleX(1)";

        gameContainer.appendChild(croc);
        obstacles.push(croc);

        gameLogger.addLog(
          `üêä Special horizontal crocodile spawned at level ${level}`,
          "info"
        );
      }

      function applyMagnetEffect(player) {
        const playerKey = player === player1 ? "player1" : "player2";

        if (
          !activePowerUps[playerKey] ||
          activePowerUps[playerKey].type !== "MAGNET"
        )
          return;

        const playerRect = player.getBoundingClientRect();
        const treasureRect = treasure.getBoundingClientRect();

        const dx = playerRect.left - treasureRect.left;
        const dy = playerRect.top - treasureRect.top;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Increased magnet range and effectiveness
        if (distance < 250) {
          console.log(
            `üß≤ Magnet active for ${playerKey}, distance: ${distance.toFixed(
              2
            )}px`
          );

          // Enhanced magnet speed based on distance (closer = faster)
          const baseSpeed = 8;
          const speedMultiplier = Math.max(0.3, (250 - distance) / 250);
          const speed = baseSpeed * speedMultiplier;

          const moveX = (dx / distance) * speed;
          const moveY = (dy / distance) * speed;

          const currentLeft = parseFloat(treasure.style.left);
          const currentTop = parseFloat(treasure.style.top);

          // Apply movement with bounds checking
          const newLeft = Math.max(
            0,
            Math.min(gameContainer.clientWidth - 60, currentLeft + moveX)
          );
          const newTop = Math.max(
            0,
            Math.min(gameContainer.clientHeight - 60, currentTop + moveY)
          );

          treasure.style.left = newLeft + "px";
          treasure.style.top = newTop + "px";

          // Add enhanced visual effect
          if (!treasure.classList.contains("magnet-active")) {
            treasure.classList.add("magnet-active");
            console.log("‚ú® Magnet visual effect activated");
          }
        } else {
          // Remove visual effect when out of range
          if (treasure.classList.contains("magnet-active")) {
            treasure.classList.remove("magnet-active");
            console.log("üîÑ Magnet visual effect deactivated");
          }
        }
      }

      function activatePowerUp(player, powerUpType) {
        const playerKey = player === player1 ? "player1" : "player2";
        const playerName = player === player1 ? player1Name : player2Name;

        // Clear existing power-up
        if (activePowerUps[playerKey]) {
          clearTimeout(activePowerUps[playerKey].timeout);
        }

        activePowerUps[playerKey] = {
          type: powerUpType,
          duration: powerUpTypes[powerUpType].duration,
        };

        playAudio(powerupSound); // Power-up sound
        showMessage(
          `‚ö° ${playerName} got ${powerUpTypes[powerUpType].effect}!`
        );

        // Update power-up status display
        updatePowerUpDisplay();

        // Set timeout to deactivate
        activePowerUps[playerKey].timeout = setTimeout(() => {
          activePowerUps[playerKey] = null;
          updatePowerUpDisplay();
          showMessage(`‚è∞ ${playerName}'s power-up expired`);
        }, powerUpTypes[powerUpType].duration * 1000);
      }

      function updatePowerUpDisplay() {
        const p1PowerUp = activePowerUps.player1;
        const p2PowerUp = activePowerUps.player2;

        if (p1PowerUp || p2PowerUp) {
          powerUpStatus.style.display = "block";
          let statusText = "";

          if (p1PowerUp) {
            statusText += `${player1Name}: ${
              powerUpTypes[p1PowerUp.type].emoji
            } ${powerUpTypes[p1PowerUp.type].effect}`;
          }
          if (p2PowerUp) {
            if (statusText) statusText += "<br>";
            statusText += `${player2Name}: ${
              powerUpTypes[p2PowerUp.type].emoji
            } ${powerUpTypes[p2PowerUp.type].effect}`;
          }

          document.getElementById("powerUpName").innerHTML = statusText;
        } else {
          powerUpStatus.style.display = "none";
        }
      }

      function checkCollisions() {
        const p1Rect = player1.getBoundingClientRect();
        const treasureRect = treasure.getBoundingClientRect();

        // Check treasure collision for player 1
        if (isOverlapping(p1Rect, treasureRect)) {
          const points = parseFloat(treasure.dataset.points) || 0.5;
          const multiplier =
            activePowerUps.player1 && activePowerUps.player1.type === "POINTS"
              ? 2
              : 1;
          const pointsEarned = points * multiplier;
          const oldScore = p1Score;
          p1Score += pointsEarned;

          logTreasure(
            player1Name,
            treasure.dataset.type,
            points,
            multiplier,
            oldScore,
            p1Score
          );
          updateDebugPanel();

          placeTreasure();
          randomObstacleRespawn(); // Trigger random obstacle respawn
          playAudio(treasureSound); // Treasure sound
          showMessage(
            `üí∞ ${player1Name} collected ${
              treasure.dataset.type
            }! +${pointsEarned.toFixed(1)} points`
          );

          // Check for level progression
          checkLevelProgress();
        }

        // Check treasure collision for player 2
        if (mode === 2) {
          const p2Rect = player2.getBoundingClientRect();
          if (isOverlapping(p2Rect, treasureRect)) {
            const points = parseFloat(treasure.dataset.points) || 0.5;
            const multiplier =
              activePowerUps.player2 && activePowerUps.player2.type === "POINTS"
                ? 2
                : 1;
            const pointsEarned = points * multiplier;
            const oldScore = p2Score;
            p2Score += pointsEarned;

            logTreasure(
              player2Name,
              treasure.dataset.type,
              points,
              multiplier,
              oldScore,
              p2Score
            );
            updateDebugPanel();

            placeTreasure();
            randomObstacleRespawn(); // Trigger random obstacle respawn
            playAudio(treasureSound);
            showMessage(
              `üí∞ ${player2Name} collected ${
                treasure.dataset.type
              }! +${pointsEarned.toFixed(1)} points`
            );

            // Check for level progression
            checkLevelProgress();
          }
        }

        // Check power-up collisions
        powerUps.forEach((powerUp, index) => {
          const powerUpRect = powerUp.getBoundingClientRect();

          if (isOverlapping(p1Rect, powerUpRect)) {
            activatePowerUp(player1, powerUp.dataset.type);
            powerUp.remove();
            powerUps.splice(index, 1);
          } else if (mode === 2) {
            const p2Rect = player2.getBoundingClientRect();
            if (isOverlapping(p2Rect, powerUpRect)) {
              activatePowerUp(player2, powerUp.dataset.type);
              powerUp.remove();
              powerUps.splice(index, 1);
            }
          }
        });

        // Check obstacle collisions
        const currentTime = Date.now();
        let p1Hit = false;
        let p2Hit = false;

        // Check if player can take damage (not in cooldown)
        const p1CanTakeDamage =
          !lastCollisionTime.player1.global ||
          currentTime - lastCollisionTime.player1.global >= COLLISION_COOLDOWN;
        const p2CanTakeDamage =
          !lastCollisionTime.player2.global ||
          currentTime - lastCollisionTime.player2.global >= COLLISION_COOLDOWN;

        obstacles.forEach((obs, obsIndex) => {
          const obsRect = obs.getBoundingClientRect();

          // Player 1 collision - only process if not already hit this cycle and can take damage
          if (
            !p1Hit &&
            p1CanTakeDamage &&
            isOverlapping(p1Rect, obsRect) &&
            !(
              activePowerUps.player1 && activePowerUps.player1.type === "SHIELD"
            )
          ) {
            p1Lives--;
            p1Hit = true;
            lastCollisionTime.player1.global = currentTime;
            playAudio(obstacleSound); // Hit sound
            showMessage(`üí• ${player1Name} hit obstacle! Lives: ${p1Lives}`);

            logCollision(player1Name, p1Lives, p1Lives <= 0);
            updateDebugPanel();

            // Only end game if lives reach 0
            if (p1Lives <= 0) {
              if (mode === 1 || p2Lives <= 0) {
                logGameOver(
                  mode === 1
                    ? "Player 1 out of lives"
                    : "Both players out of lives"
                );
                endGame();
              }
            }
          }

          // Player 2 collision - only process if not already hit this cycle and can take damage
          if (mode === 2 && !p2Hit && p2CanTakeDamage) {
            const p2Rect = player2.getBoundingClientRect();
            if (
              isOverlapping(p2Rect, obsRect) &&
              !(
                activePowerUps.player2 &&
                activePowerUps.player2.type === "SHIELD"
              )
            ) {
              p2Lives--;
              p2Hit = true;
              lastCollisionTime.player2.global = currentTime;
              playAudio(obstacleSound);
              showMessage(`üí• ${player2Name} hit obstacle! Lives: ${p2Lives}`);

              logCollision(player2Name, p2Lives, p2Lives <= 0 && p1Lives <= 0);
              updateDebugPanel();

              // Only end game if both players are out of lives
              if (p2Lives <= 0 && p1Lives <= 0) {
                logGameOver("Both players out of lives");
                endGame();
              }
            }
          }
        });
      }

      function isOverlapping(rect1, rect2) {
        return !(
          rect1.top > rect2.bottom ||
          rect1.bottom < rect2.top ||
          rect1.left > rect2.right ||
          rect1.right < rect2.left
        );
      }

      function updateDisplay() {
        document.getElementById("timeDisplay").textContent = timeLeft;
        document.getElementById("levelDisplay").textContent = level;
        document.getElementById("highScoreDisplay").textContent = highScore;

        let statsHtml = `${player1Name}: ${p1Score} points ‚ù§Ô∏è ${p1Lives} lives`;
        if (mode === 2) {
          statsHtml += `<br>${player2Name}: ${p2Score} points ‚ù§Ô∏è ${p2Lives} lives`;
        }
        document.getElementById("playerStats").innerHTML = statsHtml;
      }

      function showMessage(text) {
        achievement.innerText = text;
        achievement.style.display = "block";
        setTimeout(() => (achievement.style.display = "none"), 2500);
      }

      function levelUp() {
        level++;
        timeLeft += 10;

        if (level === 6) {
          p1Lives++;
          if (mode === 2) p2Lives++;
          showMessage("üíñ Bonus Life! +1 life added!");
        }

        createObstacles();
        playAudio(achievementSound); // Level up sound
        showMessage(`üéâ Level ${level}! +10 seconds!`);

        // Chance to spawn power-up on level up
        if (level >= 3 && Math.random() < 0.7) {
          setTimeout(createPowerUp, 1000);
        }
      }

      // Calculate points required for next level based on new progression system
      // Level 1‚Üí2: 10 pts, Level 2‚Üí3: 30 pts (10+20), Level 3‚Üí4: 60 pts (30+30), Level 4‚Üí5: 100 pts (60+40), etc.
      function getPointsForLevel(level) {
        if (level === 1) return 0;
        let total = 0;
        for (let i = 1; i < level; i++) {
          total += i * 10;
        }
        return total;
      }

      function checkLevelProgress() {
        const maxScore = Math.max(p1Score, mode === 2 ? p2Score : 0);
        const oldLevel = level;

        // Calculate what level the player should be at based on score
        let newLevel = 1;
        while (maxScore >= getPointsForLevel(newLevel + 1)) {
          newLevel++;
        }

        const currentLevelThreshold = getPointsForLevel(level);
        const nextLevelThreshold = getPointsForLevel(level + 1);
        const pointsToNext = nextLevelThreshold - maxScore;

        logLevelCheck(maxScore, level, newLevel);
        gameLogger.addLog(
          `üìä Score: ${maxScore.toFixed(
            1
          )} | Current Level ${level} threshold: ${currentLevelThreshold} | Next Level ${
            level + 1
          } at: ${nextLevelThreshold} | Points needed: ${pointsToNext.toFixed(
            1
          )}`,
          "level"
        );

        if (newLevel > level) {
          level = newLevel;
          timeLeft += 10;

          logLevelUp(oldLevel, level, obstacles.length);
          gameLogger.addLog(
            `üéä LEVEL UP! ${oldLevel} ‚Üí ${level} | Score: ${maxScore.toFixed(
              1
            )} | Next level at ${getPointsForLevel(level + 1)} points`,
            "level"
          );
          updateDebugPanel();

          if (level === 6) {
            p1Lives++;
            if (mode === 2) p2Lives++;
            gameLogger.addLog("üíñ Bonus Life granted at Level 6!", "level");
            showMessage("üíñ Bonus Life! +1 life added!");
          }

          createObstacles();

          // Add special horizontal-moving crocodile
          // Every 5th level up to 25 (5, 10, 15, 20, 25)
          // After level 25, appears every single level (26, 27, 28, 29...)
          if (shouldSpawnSpecialCrocodile(level)) {
            setTimeout(createSpecialCrocodile, 500);
          }

          playAudio(achievementSound);
          showMessage(`üéâ Level ${level}! +10 seconds!`);

          // Chance to spawn power-up on level up
          if (level >= 3 && Math.random() < 0.7) {
            setTimeout(createPowerUp, 1000);
          }
        } else {
          logNoLevelUp(newLevel);
          updateDebugPanel();
        }
      }

      function gameTick() {
        if (timeLeft > 0 && (p1Lives > 0 || (mode === 2 && p2Lives > 0))) {
          timeLeft--;
          moveObstacles();

          // Apply magnet effects
          applyMagnetEffect(player1);
          if (mode === 2) applyMagnetEffect(player2);

          updateDisplay();

          // Spawn power-ups occasionally
          if (Math.random() < 0.02) {
            // 2% chance per second
            createPowerUp();
          }
        } else {
          endGame();
        }
      }

      function startGame() {
        console.log("Starting game...");
        initAudio();

        mode = parseInt(
          document.querySelector(".mode-button.selected").dataset.mode
        );
        player1Name =
          document.getElementById("player1Name").value || "Player 1";
        player2Name =
          document.getElementById("player2Name").value || "Player 2";

        // Reset game state
        p1Score = 0;
        p2Score = 0;
        p1Lives = 2;
        p2Lives = 2;
        timeLeft = 40;
        level = 1;

        // Clear ALL debug logs and start completely fresh for new game
        gameLogger.clearAllLogs(); // Clear localStorage completely
        gameLogger.clearSessionLogs(); // Clear session logs
        logGameStart(mode, player1Name, player2Name, p1Lives);
        updateDebugPanel();
        p1X = 100;
        p1Y = 100;
        p2X = 200;
        p2Y = 200;

        // Clear power-ups
        activePowerUps = { player1: null, player2: null };
        powerUps.forEach((p) => p.remove());
        powerUps = [];

        // Reset collision tracking
        lastCollisionTime = { player1: { global: 0 }, player2: { global: 0 } };

        // Show game elements
        startscreen.style.display = "none";
        gameover.style.display = "none"; // Hide game over dialog
        document.getElementById("leaderboardModal").style.display = "none"; // Hide leaderboard
        player1.style.display = "block";
        treasure.style.display = "block";
        document.querySelector(".game-header-buttons").style.display = "flex";

        // Reset pause button to initial state
        const pauseBtn = document.getElementById("pauseButton");
        pauseBtn.innerHTML = "‚è∏ PAUSE";
        pauseBtn.style.background = "rgba(255, 193, 7, 0.8)";

        // Start background music automatically
        if (!isMuted) {
          startBackgroundMusic();
          isPlaying = true;
          const musicBtn = document.getElementById("playMusicBtn");
          if (musicBtn) {
            musicBtn.textContent = "‚è∏ Pause Music";
          }
        }

        if (mode === 2) {
          player2.style.display = "block";
        } else {
          player2.style.display = "none";
        }

        // Position players
        player1.style.left = p1X + "px";
        player1.style.top = p1Y + "px";
        player2.style.left = p2X + "px";
        player2.style.top = p2Y + "px";

        // Update player appearances based on selection
        updatePlayerAppearance();

        // Ensure background matches Player 1's character
        updateBackgroundPreview(selectedP1Character);

        // Place treasure and obstacles
        placeTreasure();
        createObstacles();

        // Update display
        updateDisplay();

        // Start game timer
        clearInterval(timer);
        timer = setInterval(gameTick, 1000);

        console.log("Game started successfully");
      }

      // Leaderboard Display Functions
      function displayLeaderboard(newEntryId = null) {
        const leaderboardBody = document.getElementById("leaderboardBody");
        const entries = leaderboard.getFormattedLeaderboard();

        leaderboardBody.innerHTML = "";

        entries.forEach((entry, index) => {
          const row = document.createElement("tr");
          row.className = `leaderboard-row position-${entry.position}`;
          row.dataset.entryId = entry.id;

          // Mark new entry for animation
          if (entry.id === newEntryId) {
            row.classList.add("new-entry");
          }

          row.innerHTML = `
            <td class="leaderboard-position">${entry.position}</td>
            <td class="leaderboard-name">${entry.name}</td>
            <td class="leaderboard-score">${entry.score}</td>
            <td class="leaderboard-date">${entry.date}</td>
          `;

          leaderboardBody.appendChild(row);
        });
      }

      function showLeaderboardWithAnimation(playerName, finalScore) {
        // First, add the score to leaderboard
        const position = leaderboard.addScore(playerName, finalScore);

        console.log(
          `Score submitted: ${playerName} - ${finalScore} points (Position: ${
            position || "Not in top 10"
          })`
        );

        // Show the leaderboard modal
        const modal = document.getElementById("leaderboardModal");
        const gameover = document.getElementById("gameover");

        // Hide game over dialog
        gameover.style.display = "none";

        // Show leaderboard
        modal.style.display = "block";

        if (position > 0) {
          // Score made it to top 10 - show with animation
          const entries = leaderboard.getFormattedLeaderboard();
          const newEntry = entries.find(
            (entry) => entry.name === playerName && entry.score === finalScore
          );

          if (newEntry) {
            displayLeaderboard(newEntry.id);
            animateScoreInsertion(newEntry.id, position);
          }
        } else {
          // Score didn't make top 10 - show regular leaderboard
          displayLeaderboard();
        }
      }

      function animateScoreInsertion(newEntryId, position) {
        setTimeout(() => {
          const newRow = document.querySelector(
            `[data-entry-id="${newEntryId}"]`
          );
          if (newRow) {
            // Add insertion animation
            newRow.classList.add("inserting");

            // Animate other rows moving down
            const allRows = document.querySelectorAll(".leaderboard-row");
            allRows.forEach((row, index) => {
              if (row.dataset.entryId !== newEntryId && index >= position - 1) {
                row.classList.add("moving-down");
              }
            });

            // Remove animation classes after animation completes
            setTimeout(() => {
              newRow.classList.remove("inserting");
              allRows.forEach((row) => row.classList.remove("moving-down"));
            }, 800);
          }
        }, 100);
      }

      function endGame() {
        clearInterval(timer);
        if (movementInterval) {
          clearInterval(movementInterval);
          movementInterval = null;
        }
        keysPressed.clear();
        stopBackgroundMusic();

        let message = `Game Over!<br>${player1Name}: ${p1Score} points`;
        if (mode === 2) {
          message += `<br>${player2Name}: ${p2Score} points`;
          const winner =
            p1Score > p2Score
              ? player1Name
              : p2Score > p1Score
              ? player2Name
              : "Tie";
          message += `<br><strong>Winner: ${winner}</strong>`;
        }

        const bestScore = Math.max(p1Score, p2Score || 0);
        const bestPlayerName =
          p1Score >= (p2Score || 0) ? player1Name : player2Name;

        if (bestScore > highScore) {
          highScore = bestScore;
          localStorage.setItem("treasureHighScore", highScore);
          message += "<br>üéâ NEW HIGH SCORE!";
        }

        playAudio(gameoverSound); // Game over sound

        // Show initial game over message briefly, then show leaderboard
        gameover.style.display = "block";
        gameover.innerHTML = `
        ${message}<br><br>
        <div style="color: #FFD700; font-size: 18px;">üìä Updating Leaderboard...</div>
      `;

        // After 2 seconds, show the leaderboard with animation
        setTimeout(() => {
          showLeaderboardWithAnimation(bestPlayerName, bestScore);
        }, 2000);
      }

      function backToMenu() {
        clearInterval(timer);
        if (movementInterval) {
          clearInterval(movementInterval);
          movementInterval = null;
        }
        keysPressed.clear();
        stopBackgroundMusic();

        player1.style.display = "none";
        player2.style.display = "none";
        treasure.style.display = "none";
        document.querySelector(".game-header-buttons").style.display = "none";
        powerUpStatus.style.display = "none";
        gameover.style.display = "none";
        document.getElementById("leaderboardModal").style.display = "none"; // Hide leaderboard

        obstacles.forEach((obs) => obs.remove());
        obstacles = [];
        powerUps.forEach((p) => p.remove());
        powerUps = [];

        startscreen.style.display = "block";
      }

      // Exit game function - returns to start screen
      function exitGame() {
        // Show confirmation dialog
        if (
          confirm(
            "Are you sure you want to exit the game? Your progress will be lost."
          )
        ) {
          playAudio(menuClickSound);
          backToMenu();
        }
      }

      // Key state tracking for simultaneous movement
      const keysPressed = new Set();
      let movementInterval = null;

      // Track key press states
      document.addEventListener("keydown", (e) => {
        keysPressed.add(e.key.toLowerCase());

        // Handle non-movement keys immediately
        if (e.key === "Escape") {
          const pauseBtn = document.getElementById("pauseButton");

          if (timer) {
            clearInterval(timer);
            timer = null;
            pauseBtn.innerHTML = "‚ñ∂ RESUME";
            pauseBtn.style.background = "rgba(40, 167, 69, 0.8)";
            showMessage("‚è∏ Game Paused - Press ESC to resume");
          } else {
            timer = setInterval(gameTick, 1000);
            pauseBtn.innerHTML = "‚è∏ PAUSE";
            pauseBtn.style.background = "rgba(255, 193, 7, 0.8)";
            showMessage("‚ñ∂ Game Resumed");
          }
          return;
        }

        // Start movement processing if not already running
        if (!movementInterval) {
          movementInterval = setInterval(processMovement, 16); // ~60fps
        }
      });

      document.addEventListener("keyup", (e) => {
        keysPressed.delete(e.key.toLowerCase());

        // Stop movement processing if no movement keys are pressed
        const movementKeys = [
          "arrowright",
          "arrowleft",
          "arrowup",
          "arrowdown",
          "w",
          "a",
          "s",
          "d",
        ];
        const hasMovementKeys = movementKeys.some((key) =>
          keysPressed.has(key)
        );

        if (!hasMovementKeys && movementInterval) {
          clearInterval(movementInterval);
          movementInterval = null;
        }
      });

      // Process movement for both players simultaneously
      function processMovement() {
        if ((p1Lives <= 0 && (mode === 1 || p2Lives <= 0)) || timeLeft <= 0) {
          if (movementInterval) {
            clearInterval(movementInterval);
            movementInterval = null;
          }
          return;
        }

        const speedMultiplier =
          activePowerUps.player1 && activePowerUps.player1.type === "SPEED"
            ? 2
            : 1;
        const speedMultiplier2 =
          activePowerUps.player2 && activePowerUps.player2.type === "SPEED"
            ? 2
            : 1;

        let moved = false;

        // Player 1 movement (Arrow Keys) - can process multiple simultaneously
        if (keysPressed.has("arrowright")) {
          p1X += moveStep * speedMultiplier;
          p1FacingLeft = false;
          moved = true;
        }
        if (keysPressed.has("arrowleft")) {
          p1X -= moveStep * speedMultiplier;
          p1FacingLeft = true;
          moved = true;
        }
        if (keysPressed.has("arrowup")) {
          p1Y -= moveStep * speedMultiplier;
          moved = true;
        }
        if (keysPressed.has("arrowdown")) {
          p1Y += moveStep * speedMultiplier;
          moved = true;
        }

        // Player 2 movement (WASD Keys) - can process multiple simultaneously
        if (mode === 2) {
          if (keysPressed.has("d")) {
            p2X += moveStep * speedMultiplier2;
            p2FacingLeft = false;
            moved = true;
          }
          if (keysPressed.has("a")) {
            p2X -= moveStep * speedMultiplier2;
            p2FacingLeft = true;
            moved = true;
          }
          if (keysPressed.has("w")) {
            p2Y -= moveStep * speedMultiplier2;
            moved = true;
          }
          if (keysPressed.has("s")) {
            p2Y += moveStep * speedMultiplier2;
            moved = true;
          }
        }

        if (moved) {
          // Keep players in bounds with smooth screen wrapping
          const game = document.getElementById("game");
          let p1Wrapped = false;
          let p2Wrapped = false;

          // Player 1 screen wrapping with smooth transition
          if (p1X < -30) {
            p1X = game.clientWidth - 30;
            p1Wrapped = true;
          } else if (p1X > game.clientWidth - 30) {
            p1X = -30;
            p1Wrapped = true;
          }
          if (p1Y < -30) {
            p1Y = game.clientHeight - 30;
            p1Wrapped = true;
          } else if (p1Y > game.clientHeight - 30) {
            p1Y = -30;
            p1Wrapped = true;
          }

          // Player 2 screen wrapping with smooth transition
          if (mode === 2) {
            if (p2X < -30) {
              p2X = game.clientWidth - 30;
              p2Wrapped = true;
            } else if (p2X > game.clientWidth - 30) {
              p2X = -30;
              p2Wrapped = true;
            }
            if (p2Y < -30) {
              p2Y = game.clientHeight - 30;
              p2Wrapped = true;
            } else if (p2Y > game.clientHeight - 30) {
              p2Y = -30;
              p2Wrapped = true;
            }
          }

          // Apply smooth wrapping effect
          if (p1Wrapped) {
            player1.style.transition = "opacity 0.15s ease-in-out";
            player1.style.opacity = "0.3";
            setTimeout(() => {
              player1.style.opacity = "1";
              setTimeout(() => {
                player1.style.transition = "none";
              }, 150);
            }, 50);
          }

          if (p2Wrapped && mode === 2) {
            player2.style.transition = "opacity 0.15s ease-in-out";
            player2.style.opacity = "0.3";
            setTimeout(() => {
              player2.style.opacity = "1";
              setTimeout(() => {
                player2.style.transition = "none";
              }, 150);
            }, 50);
          }

          // Update player positions
          player1.style.left = p1X + "px";
          player1.style.top = p1Y + "px";
          player2.style.left = p2X + "px";
          player2.style.top = p2Y + "px";

          // Update player appearance (facing direction)
          updatePlayerAppearance();

          // Check collisions
          checkCollisions();
        }
      }

      // Exit button
      document.getElementById("exitButton").addEventListener("click", () => {
        exitGame();
      });

      // Pause button
      document.getElementById("pauseButton").addEventListener("click", () => {
        const pauseBtn = document.getElementById("pauseButton");

        if (timer) {
          clearInterval(timer);
          timer = null;
          pauseBtn.innerHTML = "‚ñ∂ RESUME";
          pauseBtn.style.background = "rgba(40, 167, 69, 0.8)";
          showMessage("‚è∏ Game Paused");
        } else {
          timer = setInterval(gameTick, 1000);
          pauseBtn.innerHTML = "‚è∏ PAUSE";
          pauseBtn.style.background = "rgba(255, 193, 7, 0.8)";
          showMessage("‚ñ∂ Game Resumed");
        }
      });

      // Debug toggle button
      document.getElementById("debugToggle").addEventListener("click", () => {
        toggleDebugPanel();
      });

      // Initialize when page loads
      document.addEventListener("DOMContentLoaded", init);

      // Also initialize immediately if DOM is already loaded
      if (document.readyState !== "loading") {
        init();
      }
    </script>
  </body>
</html>
